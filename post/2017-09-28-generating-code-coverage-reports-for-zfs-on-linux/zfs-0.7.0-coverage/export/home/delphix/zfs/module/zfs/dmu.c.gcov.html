<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - zfs-0.7.0 Code Coverage - /export/home/delphix/zfs/module/zfs/dmu.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../../index.html">top level</a> - <a href="index.html">export/home/delphix/zfs/module/zfs</a> - dmu.c<span style="font-size: 80%;"> (source / <a href="dmu.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">zfs-0.7.0 Code Coverage</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">526</td>
            <td class="headerCovTableEntry">839</td>
            <td class="headerCovTableEntryLo">62.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-09-28 14:23:58</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">44</td>
            <td class="headerCovTableEntry">68</td>
            <td class="headerCovTableEntryLo">64.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
            | Branches:
            <span class="coverLegendCov">+</span> taken
            <span class="coverLegendNoCov">-</span> not taken
            <span class="coverLegendNoCov">#</span> not executed
</td>
            <td></td>
            <td class="headerItem">Branches:</td>
            <td class="headerCovTableEntry">233</td>
            <td class="headerCovTableEntry">573</td>
            <td class="headerCovTableEntryLo">40.7 %</td>
          </tr>
          <tr><td><img src="../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">           Branch data     Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>                :            : /*</a>
<span class="lineNum">       2 </span>                :            :  * CDDL HEADER START
<span class="lineNum">       3 </span>                :            :  *
<span class="lineNum">       4 </span>                :            :  * The contents of this file are subject to the terms of the
<span class="lineNum">       5 </span>                :            :  * Common Development and Distribution License (the &quot;License&quot;).
<span class="lineNum">       6 </span>                :            :  * You may not use this file except in compliance with the License.
<span class="lineNum">       7 </span>                :            :  *
<span class="lineNum">       8 </span>                :            :  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
<span class="lineNum">       9 </span>                :            :  * or http://www.opensolaris.org/os/licensing.
<span class="lineNum">      10 </span>                :            :  * See the License for the specific language governing permissions
<span class="lineNum">      11 </span>                :            :  * and limitations under the License.
<span class="lineNum">      12 </span>                :            :  *
<span class="lineNum">      13 </span>                :            :  * When distributing Covered Code, include this CDDL HEADER in each
<span class="lineNum">      14 </span>                :            :  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
<span class="lineNum">      15 </span>                :            :  * If applicable, add the following below this CDDL HEADER, with the
<span class="lineNum">      16 </span>                :            :  * fields enclosed by brackets &quot;[]&quot; replaced with your own identifying
<span class="lineNum">      17 </span>                :            :  * information: Portions Copyright [yyyy] [name of copyright owner]
<span class="lineNum">      18 </span>                :            :  *
<span class="lineNum">      19 </span>                :            :  * CDDL HEADER END
<span class="lineNum">      20 </span>                :            :  */
<span class="lineNum">      21 </span>                :            : /*
<span class="lineNum">      22 </span>                :            :  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
<span class="lineNum">      23 </span>                :            :  * Copyright (c) 2011, 2017 by Delphix. All rights reserved.
<span class="lineNum">      24 </span>                :            :  * Copyright (c) 2013 by Saso Kiselkov. All rights reserved.
<span class="lineNum">      25 </span>                :            :  * Copyright (c) 2013, Joyent, Inc. All rights reserved.
<span class="lineNum">      26 </span>                :            :  * Copyright (c) 2016, Nexenta Systems, Inc. All rights reserved.
<span class="lineNum">      27 </span>                :            :  * Copyright (c) 2015 by Chunwei Chen. All rights reserved.
<span class="lineNum">      28 </span>                :            :  */
<span class="lineNum">      29 </span>                :            : 
<span class="lineNum">      30 </span>                :            : #include &lt;sys/dmu.h&gt;
<span class="lineNum">      31 </span>                :            : #include &lt;sys/dmu_impl.h&gt;
<span class="lineNum">      32 </span>                :            : #include &lt;sys/dmu_tx.h&gt;
<span class="lineNum">      33 </span>                :            : #include &lt;sys/dbuf.h&gt;
<span class="lineNum">      34 </span>                :            : #include &lt;sys/dnode.h&gt;
<span class="lineNum">      35 </span>                :            : #include &lt;sys/zfs_context.h&gt;
<span class="lineNum">      36 </span>                :            : #include &lt;sys/dmu_objset.h&gt;
<span class="lineNum">      37 </span>                :            : #include &lt;sys/dmu_traverse.h&gt;
<span class="lineNum">      38 </span>                :            : #include &lt;sys/dsl_dataset.h&gt;
<span class="lineNum">      39 </span>                :            : #include &lt;sys/dsl_dir.h&gt;
<span class="lineNum">      40 </span>                :            : #include &lt;sys/dsl_pool.h&gt;
<span class="lineNum">      41 </span>                :            : #include &lt;sys/dsl_synctask.h&gt;
<span class="lineNum">      42 </span>                :            : #include &lt;sys/dsl_prop.h&gt;
<span class="lineNum">      43 </span>                :            : #include &lt;sys/dmu_zfetch.h&gt;
<span class="lineNum">      44 </span>                :            : #include &lt;sys/zfs_ioctl.h&gt;
<span class="lineNum">      45 </span>                :            : #include &lt;sys/zap.h&gt;
<span class="lineNum">      46 </span>                :            : #include &lt;sys/zio_checksum.h&gt;
<span class="lineNum">      47 </span>                :            : #include &lt;sys/zio_compress.h&gt;
<span class="lineNum">      48 </span>                :            : #include &lt;sys/sa.h&gt;
<span class="lineNum">      49 </span>                :            : #include &lt;sys/zfeature.h&gt;
<span class="lineNum">      50 </span>                :            : #include &lt;sys/abd.h&gt;
<span class="lineNum">      51 </span>                :            : #include &lt;sys/trace_dmu.h&gt;
<span class="lineNum">      52 </span>                :            : #include &lt;sys/zfs_rlock.h&gt;
<span class="lineNum">      53 </span>                :            : #ifdef _KERNEL
<span class="lineNum">      54 </span>                :            : #include &lt;sys/vmsystm.h&gt;
<span class="lineNum">      55 </span>                :            : #include &lt;sys/zfs_znode.h&gt;
<span class="lineNum">      56 </span>                :            : #endif
<span class="lineNum">      57 </span>                :            : 
<span class="lineNum">      58 </span>                :            : /*
<span class="lineNum">      59 </span>                :            :  * Enable/disable nopwrite feature.
<span class="lineNum">      60 </span>                :            :  */
<span class="lineNum">      61 </span>                :            : int zfs_nopwrite_enabled = 1;
<span class="lineNum">      62 </span>                :            : 
<span class="lineNum">      63 </span>                :            : /*
<span class="lineNum">      64 </span>                :            :  * Tunable to control percentage of dirtied blocks from frees in one TXG.
<span class="lineNum">      65 </span>                :            :  * After this threshold is crossed, additional dirty blocks from frees
<span class="lineNum">      66 </span>                :            :  * wait until the next TXG.
<span class="lineNum">      67 </span>                :            :  * A value of zero will disable this throttle.
<span class="lineNum">      68 </span>                :            :  */
<span class="lineNum">      69 </span>                :            : unsigned long zfs_per_txg_dirty_frees_percent = 30;
<span class="lineNum">      70 </span>                :            : 
<span class="lineNum">      71 </span>                :            : /*
<span class="lineNum">      72 </span>                :            :  * Enable/disable forcing txg sync when dirty in dmu_offset_next.
<span class="lineNum">      73 </span>                :            :  */
<span class="lineNum">      74 </span>                :            : int zfs_dmu_offset_next_sync = 0;
<span class="lineNum">      75 </span>                :            : 
<span class="lineNum">      76 </span>                :            : const dmu_object_type_info_t dmu_ot[DMU_OT_NUMTYPES] = {
<span class="lineNum">      77 </span>                :            :         { DMU_BSWAP_UINT8,      TRUE,   FALSE,  &quot;unallocated&quot;         },
<span class="lineNum">      78 </span>                :            :         { DMU_BSWAP_ZAP,        TRUE,   FALSE,  &quot;object directory&quot;    },
<span class="lineNum">      79 </span>                :            :         { DMU_BSWAP_UINT64,     TRUE,   FALSE,  &quot;object array&quot;                },
<span class="lineNum">      80 </span>                :            :         { DMU_BSWAP_UINT8,      TRUE,   FALSE,  &quot;packed nvlist&quot;               },
<span class="lineNum">      81 </span>                :            :         { DMU_BSWAP_UINT64,     TRUE,   FALSE,  &quot;packed nvlist size&quot;  },
<span class="lineNum">      82 </span>                :            :         { DMU_BSWAP_UINT64,     TRUE,   FALSE,  &quot;bpobj&quot;                       },
<span class="lineNum">      83 </span>                :            :         { DMU_BSWAP_UINT64,     TRUE,   FALSE,  &quot;bpobj header&quot;                },
<span class="lineNum">      84 </span>                :            :         { DMU_BSWAP_UINT64,     TRUE,   FALSE,  &quot;SPA space map header&quot;        },
<span class="lineNum">      85 </span>                :            :         { DMU_BSWAP_UINT64,     TRUE,   FALSE,  &quot;SPA space map&quot;               },
<span class="lineNum">      86 </span>                :            :         { DMU_BSWAP_UINT64,     TRUE,   TRUE,   &quot;ZIL intent log&quot;      },
<span class="lineNum">      87 </span>                :            :         { DMU_BSWAP_DNODE,      TRUE,   TRUE,   &quot;DMU dnode&quot;           },
<span class="lineNum">      88 </span>                :            :         { DMU_BSWAP_OBJSET,     TRUE,   FALSE,  &quot;DMU objset&quot;          },
<span class="lineNum">      89 </span>                :            :         { DMU_BSWAP_UINT64,     TRUE,   FALSE,  &quot;DSL directory&quot;               },
<span class="lineNum">      90 </span>                :            :         { DMU_BSWAP_ZAP,        TRUE,   FALSE,  &quot;DSL directory child map&quot;},
<span class="lineNum">      91 </span>                :            :         { DMU_BSWAP_ZAP,        TRUE,   FALSE,  &quot;DSL dataset snap map&quot;        },
<span class="lineNum">      92 </span>                :            :         { DMU_BSWAP_ZAP,        TRUE,   FALSE,  &quot;DSL props&quot;           },
<span class="lineNum">      93 </span>                :            :         { DMU_BSWAP_UINT64,     TRUE,   FALSE,  &quot;DSL dataset&quot;         },
<span class="lineNum">      94 </span>                :            :         { DMU_BSWAP_ZNODE,      TRUE,   FALSE,  &quot;ZFS znode&quot;           },
<span class="lineNum">      95 </span>                :            :         { DMU_BSWAP_OLDACL,     TRUE,   TRUE,   &quot;ZFS V0 ACL&quot;          },
<span class="lineNum">      96 </span>                :            :         { DMU_BSWAP_UINT8,      FALSE,  TRUE,   &quot;ZFS plain file&quot;      },
<span class="lineNum">      97 </span>                :            :         { DMU_BSWAP_ZAP,        TRUE,   TRUE,   &quot;ZFS directory&quot;               },
<span class="lineNum">      98 </span>                :            :         { DMU_BSWAP_ZAP,        TRUE,   FALSE,  &quot;ZFS master node&quot;     },
<span class="lineNum">      99 </span>                :            :         { DMU_BSWAP_ZAP,        TRUE,   TRUE,   &quot;ZFS delete queue&quot;    },
<span class="lineNum">     100 </span>                :            :         { DMU_BSWAP_UINT8,      FALSE,  TRUE,   &quot;zvol object&quot;         },
<span class="lineNum">     101 </span>                :            :         { DMU_BSWAP_ZAP,        TRUE,   FALSE,  &quot;zvol prop&quot;           },
<span class="lineNum">     102 </span>                :            :         { DMU_BSWAP_UINT8,      FALSE,  TRUE,   &quot;other uint8[]&quot;               },
<span class="lineNum">     103 </span>                :            :         { DMU_BSWAP_UINT64,     FALSE,  TRUE,   &quot;other uint64[]&quot;      },
<span class="lineNum">     104 </span>                :            :         { DMU_BSWAP_ZAP,        TRUE,   FALSE,  &quot;other ZAP&quot;           },
<span class="lineNum">     105 </span>                :            :         { DMU_BSWAP_ZAP,        TRUE,   FALSE,  &quot;persistent error log&quot;        },
<span class="lineNum">     106 </span>                :            :         { DMU_BSWAP_UINT8,      TRUE,   FALSE,  &quot;SPA history&quot;         },
<span class="lineNum">     107 </span>                :            :         { DMU_BSWAP_UINT64,     TRUE,   FALSE,  &quot;SPA history offsets&quot; },
<span class="lineNum">     108 </span>                :            :         { DMU_BSWAP_ZAP,        TRUE,   FALSE,  &quot;Pool properties&quot;     },
<span class="lineNum">     109 </span>                :            :         { DMU_BSWAP_ZAP,        TRUE,   FALSE,  &quot;DSL permissions&quot;     },
<span class="lineNum">     110 </span>                :            :         { DMU_BSWAP_ACL,        TRUE,   TRUE,   &quot;ZFS ACL&quot;             },
<span class="lineNum">     111 </span>                :            :         { DMU_BSWAP_UINT8,      TRUE,   TRUE,   &quot;ZFS SYSACL&quot;          },
<span class="lineNum">     112 </span>                :            :         { DMU_BSWAP_UINT8,      TRUE,   TRUE,   &quot;FUID table&quot;          },
<span class="lineNum">     113 </span>                :            :         { DMU_BSWAP_UINT64,     TRUE,   FALSE,  &quot;FUID table size&quot;     },
<span class="lineNum">     114 </span>                :            :         { DMU_BSWAP_ZAP,        TRUE,   FALSE,  &quot;DSL dataset next clones&quot;},
<span class="lineNum">     115 </span>                :            :         { DMU_BSWAP_ZAP,        TRUE,   FALSE,  &quot;scan work queue&quot;     },
<span class="lineNum">     116 </span>                :            :         { DMU_BSWAP_ZAP,        TRUE,   TRUE,   &quot;ZFS user/group used&quot; },
<span class="lineNum">     117 </span>                :            :         { DMU_BSWAP_ZAP,        TRUE,   TRUE,   &quot;ZFS user/group quota&quot;        },
<span class="lineNum">     118 </span>                :            :         { DMU_BSWAP_ZAP,        TRUE,   FALSE,  &quot;snapshot refcount tags&quot;},
<span class="lineNum">     119 </span>                :            :         { DMU_BSWAP_ZAP,        TRUE,   FALSE,  &quot;DDT ZAP algorithm&quot;   },
<span class="lineNum">     120 </span>                :            :         { DMU_BSWAP_ZAP,        TRUE,   FALSE,  &quot;DDT statistics&quot;      },
<span class="lineNum">     121 </span>                :            :         { DMU_BSWAP_UINT8,      TRUE,   TRUE,   &quot;System attributes&quot;   },
<span class="lineNum">     122 </span>                :            :         { DMU_BSWAP_ZAP,        TRUE,   TRUE,   &quot;SA master node&quot;      },
<span class="lineNum">     123 </span>                :            :         { DMU_BSWAP_ZAP,        TRUE,   TRUE,   &quot;SA attr registration&quot;        },
<span class="lineNum">     124 </span>                :            :         { DMU_BSWAP_ZAP,        TRUE,   TRUE,   &quot;SA attr layouts&quot;     },
<span class="lineNum">     125 </span>                :            :         { DMU_BSWAP_ZAP,        TRUE,   FALSE,  &quot;scan translations&quot;   },
<span class="lineNum">     126 </span>                :            :         { DMU_BSWAP_UINT8,      FALSE,  TRUE,   &quot;deduplicated block&quot;  },
<span class="lineNum">     127 </span>                :            :         { DMU_BSWAP_ZAP,        TRUE,   FALSE,  &quot;DSL deadlist map&quot;    },
<span class="lineNum">     128 </span>                :            :         { DMU_BSWAP_UINT64,     TRUE,   FALSE,  &quot;DSL deadlist map hdr&quot;        },
<span class="lineNum">     129 </span>                :            :         { DMU_BSWAP_ZAP,        TRUE,   FALSE,  &quot;DSL dir clones&quot;      },
<span class="lineNum">     130 </span>                :            :         { DMU_BSWAP_UINT64,     TRUE,   FALSE,  &quot;bpobj subobj&quot;                }
<span class="lineNum">     131 </span>                :            : };
<span class="lineNum">     132 </span>                :            : 
<span class="lineNum">     133 </span>                :            : const dmu_object_byteswap_info_t dmu_ot_byteswap[DMU_BSWAP_NUMFUNCS] = {
<span class="lineNum">     134 </span>                :            :         {       byteswap_uint8_array,   &quot;uint8&quot;               },
<span class="lineNum">     135 </span>                :            :         {       byteswap_uint16_array,  &quot;uint16&quot;      },
<span class="lineNum">     136 </span>                :            :         {       byteswap_uint32_array,  &quot;uint32&quot;      },
<span class="lineNum">     137 </span>                :            :         {       byteswap_uint64_array,  &quot;uint64&quot;      },
<span class="lineNum">     138 </span>                :            :         {       zap_byteswap,           &quot;zap&quot;         },
<span class="lineNum">     139 </span>                :            :         {       dnode_buf_byteswap,     &quot;dnode&quot;               },
<span class="lineNum">     140 </span>                :            :         {       dmu_objset_byteswap,    &quot;objset&quot;      },
<span class="lineNum">     141 </span>                :            :         {       zfs_znode_byteswap,     &quot;znode&quot;               },
<span class="lineNum">     142 </span>                :            :         {       zfs_oldacl_byteswap,    &quot;oldacl&quot;      },
<span class="lineNum">     143 </span>                :            :         {       zfs_acl_byteswap,       &quot;acl&quot;         }
<span class="lineNum">     144 </span>                :            : };
<a name="145"><span class="lineNum">     145 </span>                :            : </a>
<span class="lineNum">     146 </span>                :            : int
<span class="lineNum">     147 </span>                :<span class="lineCov">     252547 : dmu_buf_hold_noread_by_dnode(dnode_t *dn, uint64_t offset,</span>
<span class="lineNum">     148 </span>                :            :     void *tag, dmu_buf_t **dbp)
<span class="lineNum">     149 </span>                :            : {
<span class="lineNum">     150 </span>                :            :         uint64_t blkid;
<span class="lineNum">     151 </span>                :            :         dmu_buf_impl_t *db;
<span class="lineNum">     152 </span>                :            : 
<span class="lineNum">     153 </span>                :<span class="lineCov">     252547 :         blkid = dbuf_whichblock(dn, 0, offset);</span>
<span class="lineNum">     154 </span>                :<span class="lineCov">     252519 :         rw_enter(&amp;dn-&gt;dn_struct_rwlock, RW_READER);</span>
<span class="lineNum">     155 </span>                :<span class="lineCov">     252560 :         db = dbuf_hold(dn, blkid, tag);</span>
<span class="lineNum">     156 </span>                :<span class="lineCov">     252570 :         rw_exit(&amp;dn-&gt;dn_struct_rwlock);</span>
<span class="lineNum">     157 </span>                :            : 
<span class="lineNum">     158 </span>        [<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 252574 times"> + </span>]:<span class="lineCov">     252574 :         if (db == NULL) {</span>
<span class="lineNum">     159 </span>                :<span class="lineNoCov">          0 :                 *dbp = NULL;</span>
<span class="lineNum">     160 </span>                :<span class="lineNoCov">          0 :                 return (SET_ERROR(EIO));</span>
<span class="lineNum">     161 </span>                :            :         }
<span class="lineNum">     162 </span>                :            : 
<span class="lineNum">     163 </span>                :<span class="lineCov">     252574 :         *dbp = &amp;db-&gt;db;</span>
<span class="lineNum">     164 </span>                :<span class="lineCov">     252574 :         return (0);</span>
<a name="165"><span class="lineNum">     165 </span>                :            : }</a>
<span class="lineNum">     166 </span>                :            : int
<span class="lineNum">     167 </span>                :<span class="lineCov">    1623868 : dmu_buf_hold_noread(objset_t *os, uint64_t object, uint64_t offset,</span>
<span class="lineNum">     168 </span>                :            :     void *tag, dmu_buf_t **dbp)
<span class="lineNum">     169 </span>                :            : {
<span class="lineNum">     170 </span>                :            :         dnode_t *dn;
<span class="lineNum">     171 </span>                :            :         uint64_t blkid;
<span class="lineNum">     172 </span>                :            :         dmu_buf_impl_t *db;
<span class="lineNum">     173 </span>                :            :         int err;
<span class="lineNum">     174 </span>                :            : 
<span class="lineNum">     175 </span>                :<span class="lineCov">    1623868 :         err = dnode_hold(os, object, FTAG, &amp;dn);</span>
<span class="lineNum">     176 </span>        [<span class="branchCov" title="Branch 0 was taken 1624498 times"> + </span><span class="branchCov" title="Branch 1 was taken 208 times"> + </span>]:<span class="lineCov">    1624706 :         if (err)</span>
<span class="lineNum">     177 </span>                :            :                 return (err);
<span class="lineNum">     178 </span>                :<span class="lineCov">    1624498 :         blkid = dbuf_whichblock(dn, 0, offset);</span>
<span class="lineNum">     179 </span>                :<span class="lineCov">    1624466 :         rw_enter(&amp;dn-&gt;dn_struct_rwlock, RW_READER);</span>
<span class="lineNum">     180 </span>                :<span class="lineCov">    1624639 :         db = dbuf_hold(dn, blkid, tag);</span>
<span class="lineNum">     181 </span>                :<span class="lineCov">    1624402 :         rw_exit(&amp;dn-&gt;dn_struct_rwlock);</span>
<span class="lineNum">     182 </span>                :<span class="lineCov">    1624519 :         dnode_rele(dn, FTAG);</span>
<span class="lineNum">     183 </span>                :            : 
<span class="lineNum">     184 </span>        [<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 1624375 times"> + </span>]:<span class="lineCov">    1624375 :         if (db == NULL) {</span>
<span class="lineNum">     185 </span>                :<span class="lineNoCov">          0 :                 *dbp = NULL;</span>
<span class="lineNum">     186 </span>                :<span class="lineNoCov">          0 :                 return (SET_ERROR(EIO));</span>
<span class="lineNum">     187 </span>                :            :         }
<span class="lineNum">     188 </span>                :            : 
<span class="lineNum">     189 </span>                :<span class="lineCov">    1624375 :         *dbp = &amp;db-&gt;db;</span>
<span class="lineNum">     190 </span>                :<span class="lineCov">    1624375 :         return (err);</span>
<span class="lineNum">     191 </span>                :            : }
<a name="192"><span class="lineNum">     192 </span>                :            : </a>
<span class="lineNum">     193 </span>                :            : int
<span class="lineNum">     194 </span>                :<span class="lineCov">     252568 : dmu_buf_hold_by_dnode(dnode_t *dn, uint64_t offset,</span>
<span class="lineNum">     195 </span>                :            :     void *tag, dmu_buf_t **dbp, int flags)
<span class="lineNum">     196 </span>                :            : {
<span class="lineNum">     197 </span>                :            :         int err;
<span class="lineNum">     198 </span>                :<span class="lineCov">     252568 :         int db_flags = DB_RF_CANFAIL;</span>
<span class="lineNum">     199 </span>                :            : 
<span class="lineNum">     200 </span>        [<span class="branchCov" title="Branch 0 was taken 252568 times"> + </span><span class="branchNoCov" title="Branch 1 was not taken"> - </span>]:<span class="lineCov">     252568 :         if (flags &amp; DMU_READ_NO_PREFETCH)</span>
<span class="lineNum">     201 </span>                :<span class="lineCov">     252568 :                 db_flags |= DB_RF_NOPREFETCH;</span>
<span class="lineNum">     202 </span>        [<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 252568 times"> + </span>]:<span class="lineCov">     252568 :         if (flags &amp; DMU_READ_NO_DECRYPT)</span>
<span class="lineNum">     203 </span>                :<span class="lineNoCov">          0 :                 db_flags |= DB_RF_NO_DECRYPT;</span>
<span class="lineNum">     204 </span>                :            : 
<span class="lineNum">     205 </span>                :<span class="lineCov">     252568 :         err = dmu_buf_hold_noread_by_dnode(dn, offset, tag, dbp);</span>
<span class="lineNum">     206 </span>        [<span class="branchCov" title="Branch 0 was taken 252573 times"> + </span><span class="branchNoCov" title="Branch 1 was not taken"> - </span>]:<span class="lineCov">     252573 :         if (err == 0) {</span>
<span class="lineNum">     207 </span>                :<span class="lineCov">     252573 :                 dmu_buf_impl_t *db = (dmu_buf_impl_t *)(*dbp);</span>
<span class="lineNum">     208 </span>                :<span class="lineCov">     252573 :                 err = dbuf_read(db, NULL, db_flags);</span>
<span class="lineNum">     209 </span>        [<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 252569 times"> + </span>]:<span class="lineCov">     252569 :                 if (err != 0) {</span>
<span class="lineNum">     210 </span>                :<span class="lineNoCov">          0 :                         dbuf_rele(db, tag);</span>
<span class="lineNum">     211 </span>                :<span class="lineNoCov">          0 :                         *dbp = NULL;</span>
<span class="lineNum">     212 </span>                :            :                 }
<span class="lineNum">     213 </span>                :            :         }
<span class="lineNum">     214 </span>                :            : 
<span class="lineNum">     215 </span>                :<span class="lineCov">     252569 :         return (err);</span>
<span class="lineNum">     216 </span>                :            : }
<a name="217"><span class="lineNum">     217 </span>                :            : </a>
<span class="lineNum">     218 </span>                :            : int
<span class="lineNum">     219 </span>                :<span class="lineCov">    1623927 : dmu_buf_hold(objset_t *os, uint64_t object, uint64_t offset,</span>
<span class="lineNum">     220 </span>                :            :     void *tag, dmu_buf_t **dbp, int flags)
<span class="lineNum">     221 </span>                :            : {
<span class="lineNum">     222 </span>                :            :         int err;
<span class="lineNum">     223 </span>                :<span class="lineCov">    1623927 :         int db_flags = DB_RF_CANFAIL;</span>
<span class="lineNum">     224 </span>                :            : 
<span class="lineNum">     225 </span>        [<span class="branchCov" title="Branch 0 was taken 1612356 times"> + </span><span class="branchCov" title="Branch 1 was taken 11571 times"> + </span>]:<span class="lineCov">    1623927 :         if (flags &amp; DMU_READ_NO_PREFETCH)</span>
<span class="lineNum">     226 </span>                :<span class="lineCov">    1612356 :                 db_flags |= DB_RF_NOPREFETCH;</span>
<span class="lineNum">     227 </span>        [<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 1623927 times"> + </span>]:<span class="lineCov">    1623927 :         if (flags &amp; DMU_READ_NO_DECRYPT)</span>
<span class="lineNum">     228 </span>                :<span class="lineNoCov">          0 :                 db_flags |= DB_RF_NO_DECRYPT;</span>
<span class="lineNum">     229 </span>                :            : 
<span class="lineNum">     230 </span>                :<span class="lineCov">    1623927 :         err = dmu_buf_hold_noread(os, object, offset, tag, dbp);</span>
<span class="lineNum">     231 </span>        [<span class="branchCov" title="Branch 0 was taken 1624296 times"> + </span><span class="branchCov" title="Branch 1 was taken 243 times"> + </span>]:<span class="lineCov">    1624539 :         if (err == 0) {</span>
<span class="lineNum">     232 </span>                :<span class="lineCov">    1624296 :                 dmu_buf_impl_t *db = (dmu_buf_impl_t *)(*dbp);</span>
<span class="lineNum">     233 </span>                :<span class="lineCov">    1624296 :                 err = dbuf_read(db, NULL, db_flags);</span>
<span class="lineNum">     234 </span>        [<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 1623155 times"> + </span>]:<span class="lineCov">    1623155 :                 if (err != 0) {</span>
<span class="lineNum">     235 </span>                :<span class="lineNoCov">          0 :                         dbuf_rele(db, tag);</span>
<span class="lineNum">     236 </span>                :<span class="lineNoCov">          0 :                         *dbp = NULL;</span>
<span class="lineNum">     237 </span>                :            :                 }
<span class="lineNum">     238 </span>                :            :         }
<span class="lineNum">     239 </span>                :            : 
<span class="lineNum">     240 </span>                :<span class="lineCov">    1623398 :         return (err);</span>
<span class="lineNum">     241 </span>                :            : }
<a name="242"><span class="lineNum">     242 </span>                :            : </a>
<span class="lineNum">     243 </span>                :            : int
<span class="lineNum">     244 </span>                :<span class="lineCov">        801 : dmu_bonus_max(void)</span>
<span class="lineNum">     245 </span>                :            : {
<span class="lineNum">     246 </span>                :<span class="lineCov">        801 :         return (DN_OLD_MAX_BONUSLEN);</span>
<span class="lineNum">     247 </span>                :            : }
<a name="248"><span class="lineNum">     248 </span>                :            : </a>
<span class="lineNum">     249 </span>                :            : int
<span class="lineNum">     250 </span>                :<span class="lineCov">       2510 : dmu_set_bonus(dmu_buf_t *db_fake, int newsize, dmu_tx_t *tx)</span>
<span class="lineNum">     251 </span>                :            : {
<span class="lineNum">     252 </span>                :<span class="lineCov">       2510 :         dmu_buf_impl_t *db = (dmu_buf_impl_t *)db_fake;</span>
<span class="lineNum">     253 </span>                :            :         dnode_t *dn;
<span class="lineNum">     254 </span>                :            :         int error;
<span class="lineNum">     255 </span>                :            : 
<span class="lineNum">     256 </span>                :<span class="lineCov">       2510 :         DB_DNODE_ENTER(db);</span>
<span class="lineNum">     257 </span>                :<span class="lineCov">       2511 :         dn = DB_DNODE(db);</span>
<span class="lineNum">     258 </span>                :            : 
<span class="lineNum">     259 </span>        [<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 2511 times"> + </span>]:<span class="lineCov">       2511 :         if (dn-&gt;dn_bonus != db) {</span>
<span class="lineNum">     260 </span>                :<span class="lineNoCov">          0 :                 error = SET_ERROR(EINVAL);</span>
<span class="lineNum">     261 </span>[<span class="branchCov" title="Branch 0 was taken 2511 times"> + </span><span class="branchNoCov" title="Branch 1 was not taken"> - </span>][<span class="branchCov" title="Branch 2 was taken 1 time"> + </span><span class="branchCov" title="Branch 3 was taken 2510 times"> + </span>]:<span class="lineCov">       2511 :         } else if (newsize &lt; 0 || newsize &gt; db_fake-&gt;db_size) {</span>
<span class="lineNum">     262 </span>                :<span class="lineCov">          1 :                 error = SET_ERROR(EINVAL);</span>
<span class="lineNum">     263 </span>                :            :         } else {
<span class="lineNum">     264 </span>                :<span class="lineCov">       2510 :                 dnode_setbonuslen(dn, newsize, tx);</span>
<span class="lineNum">     265 </span>                :<span class="lineCov">       2510 :                 error = 0;</span>
<span class="lineNum">     266 </span>                :            :         }
<span class="lineNum">     267 </span>                :            : 
<span class="lineNum">     268 </span>                :<span class="lineCov">       2511 :         DB_DNODE_EXIT(db);</span>
<span class="lineNum">     269 </span>                :<span class="lineCov">       2510 :         return (error);</span>
<span class="lineNum">     270 </span>                :            : }
<a name="271"><span class="lineNum">     271 </span>                :            : </a>
<span class="lineNum">     272 </span>                :            : int
<span class="lineNum">     273 </span>                :<span class="lineNoCov">          0 : dmu_set_bonustype(dmu_buf_t *db_fake, dmu_object_type_t type, dmu_tx_t *tx)</span>
<span class="lineNum">     274 </span>                :            : {
<span class="lineNum">     275 </span>                :<span class="lineNoCov">          0 :         dmu_buf_impl_t *db = (dmu_buf_impl_t *)db_fake;</span>
<span class="lineNum">     276 </span>                :            :         dnode_t *dn;
<span class="lineNum">     277 </span>                :            :         int error;
<span class="lineNum">     278 </span>                :            : 
<span class="lineNum">     279 </span>                :<span class="lineNoCov">          0 :         DB_DNODE_ENTER(db);</span>
<span class="lineNum">     280 </span>                :<span class="lineNoCov">          0 :         dn = DB_DNODE(db);</span>
<span class="lineNum">     281 </span>                :            : 
<span class="lineNum">     282 </span>[<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>][<span class="branchNoExec" title="Branch 2 was not executed"> # </span><span class="branchNoExec" title="Branch 3 was not executed"> # </span>]:<span class="lineNoCov">          0 :         if (!DMU_OT_IS_VALID(type)) {</span>
<span class="lineNum">     283 </span>                :<span class="lineNoCov">          0 :                 error = SET_ERROR(EINVAL);</span>
<span class="lineNum">     284 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :         } else if (dn-&gt;dn_bonus != db) {</span>
<span class="lineNum">     285 </span>                :<span class="lineNoCov">          0 :                 error = SET_ERROR(EINVAL);</span>
<span class="lineNum">     286 </span>                :            :         } else {
<span class="lineNum">     287 </span>                :<span class="lineNoCov">          0 :                 dnode_setbonus_type(dn, type, tx);</span>
<span class="lineNum">     288 </span>                :<span class="lineNoCov">          0 :                 error = 0;</span>
<span class="lineNum">     289 </span>                :            :         }
<span class="lineNum">     290 </span>                :            : 
<span class="lineNum">     291 </span>                :<span class="lineNoCov">          0 :         DB_DNODE_EXIT(db);</span>
<span class="lineNum">     292 </span>                :<span class="lineNoCov">          0 :         return (error);</span>
<span class="lineNum">     293 </span>                :            : }
<a name="294"><span class="lineNum">     294 </span>                :            : </a>
<span class="lineNum">     295 </span>                :            : dmu_object_type_t
<span class="lineNum">     296 </span>                :<span class="lineCov">        100 : dmu_get_bonustype(dmu_buf_t *db_fake)</span>
<span class="lineNum">     297 </span>                :            : {
<span class="lineNum">     298 </span>                :<span class="lineCov">        100 :         dmu_buf_impl_t *db = (dmu_buf_impl_t *)db_fake;</span>
<span class="lineNum">     299 </span>                :            :         dnode_t *dn;
<span class="lineNum">     300 </span>                :            :         dmu_object_type_t type;
<span class="lineNum">     301 </span>                :            : 
<span class="lineNum">     302 </span>                :<span class="lineCov">        100 :         DB_DNODE_ENTER(db);</span>
<span class="lineNum">     303 </span>                :<span class="lineCov">        100 :         dn = DB_DNODE(db);</span>
<span class="lineNum">     304 </span>                :<span class="lineCov">        100 :         type = dn-&gt;dn_bonustype;</span>
<span class="lineNum">     305 </span>                :<span class="lineCov">        100 :         DB_DNODE_EXIT(db);</span>
<span class="lineNum">     306 </span>                :            : 
<span class="lineNum">     307 </span>                :<span class="lineCov">        100 :         return (type);</span>
<span class="lineNum">     308 </span>                :            : }
<a name="309"><span class="lineNum">     309 </span>                :            : </a>
<span class="lineNum">     310 </span>                :            : int
<span class="lineNum">     311 </span>                :<span class="lineNoCov">          0 : dmu_rm_spill(objset_t *os, uint64_t object, dmu_tx_t *tx)</span>
<span class="lineNum">     312 </span>                :            : {
<span class="lineNum">     313 </span>                :            :         dnode_t *dn;
<span class="lineNum">     314 </span>                :            :         int error;
<span class="lineNum">     315 </span>                :            : 
<span class="lineNum">     316 </span>                :<span class="lineNoCov">          0 :         error = dnode_hold(os, object, FTAG, &amp;dn);</span>
<span class="lineNum">     317 </span>                :<span class="lineNoCov">          0 :         dbuf_rm_spill(dn, tx);</span>
<span class="lineNum">     318 </span>                :<span class="lineNoCov">          0 :         rw_enter(&amp;dn-&gt;dn_struct_rwlock, RW_WRITER);</span>
<span class="lineNum">     319 </span>                :<span class="lineNoCov">          0 :         dnode_rm_spill(dn, tx);</span>
<span class="lineNum">     320 </span>                :<span class="lineNoCov">          0 :         rw_exit(&amp;dn-&gt;dn_struct_rwlock);</span>
<span class="lineNum">     321 </span>                :<span class="lineNoCov">          0 :         dnode_rele(dn, FTAG);</span>
<span class="lineNum">     322 </span>                :<span class="lineNoCov">          0 :         return (error);</span>
<span class="lineNum">     323 </span>                :            : }
<span class="lineNum">     324 </span>                :            : 
<span class="lineNum">     325 </span>                :            : /*
<span class="lineNum">     326 </span>                :            :  * returns ENOENT, EIO, or 0.
<a name="327"><span class="lineNum">     327 </span>                :            :  */</a>
<span class="lineNum">     328 </span>                :            : int
<span class="lineNum">     329 </span>                :<span class="lineCov">     608995 : dmu_bonus_hold_impl(objset_t *os, uint64_t object, void *tag, uint32_t flags,</span>
<span class="lineNum">     330 </span>                :            :     dmu_buf_t **dbp)
<span class="lineNum">     331 </span>                :            : {
<span class="lineNum">     332 </span>                :            :         dnode_t *dn;
<span class="lineNum">     333 </span>                :            :         dmu_buf_impl_t *db;
<span class="lineNum">     334 </span>                :            :         int error;
<span class="lineNum">     335 </span>                :<span class="lineCov">     608995 :         uint32_t db_flags = DB_RF_MUST_SUCCEED;</span>
<span class="lineNum">     336 </span>                :            : 
<span class="lineNum">     337 </span>           [<span class="branchCov" title="Branch 0 was taken 608998 times"> + </span>]:<span class="lineCov">     608995 :         if (flags &amp; DMU_READ_NO_PREFETCH)</span>
<span class="lineNum">     338 </span>                :<span class="lineCov">     608998 :                 db_flags |= DB_RF_NOPREFETCH;</span>
<span class="lineNum">     339 </span>        [<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 608995 times"> + </span>]:<span class="lineCov">     608995 :         if (flags &amp; DMU_READ_NO_DECRYPT)</span>
<span class="lineNum">     340 </span>                :<span class="lineNoCov">          0 :                 db_flags |= DB_RF_NO_DECRYPT;</span>
<span class="lineNum">     341 </span>                :            : 
<span class="lineNum">     342 </span>                :<span class="lineCov">     608995 :         error = dnode_hold(os, object, FTAG, &amp;dn);</span>
<span class="lineNum">     343 </span>        [<span class="branchCov" title="Branch 0 was taken 608977 times"> + </span><span class="branchCov" title="Branch 1 was taken 55 times"> + </span>]:<span class="lineCov">     609032 :         if (error)</span>
<span class="lineNum">     344 </span>                :            :                 return (error);
<span class="lineNum">     345 </span>                :            : 
<span class="lineNum">     346 </span>                :<span class="lineCov">     608977 :         rw_enter(&amp;dn-&gt;dn_struct_rwlock, RW_READER);</span>
<span class="lineNum">     347 </span>        [<span class="branchCov" title="Branch 0 was taken 208676 times"> + </span><span class="branchCov" title="Branch 1 was taken 400325 times"> + </span>]:<span class="lineCov">     609001 :         if (dn-&gt;dn_bonus == NULL) {</span>
<span class="lineNum">     348 </span>                :<span class="lineCov">     208676 :                 rw_exit(&amp;dn-&gt;dn_struct_rwlock);</span>
<span class="lineNum">     349 </span>                :<span class="lineCov">     208672 :                 rw_enter(&amp;dn-&gt;dn_struct_rwlock, RW_WRITER);</span>
<span class="lineNum">     350 </span>        [<span class="branchCov" title="Branch 0 was taken 208674 times"> + </span><span class="branchNoCov" title="Branch 1 was not taken"> - </span>]:<span class="lineCov">     208674 :                 if (dn-&gt;dn_bonus == NULL)</span>
<span class="lineNum">     351 </span>                :<span class="lineCov">     208674 :                         dbuf_create_bonus(dn);</span>
<span class="lineNum">     352 </span>                :            :         }
<span class="lineNum">     353 </span>                :<span class="lineCov">     609003 :         db = dn-&gt;dn_bonus;</span>
<span class="lineNum">     354 </span>                :            : 
<span class="lineNum">     355 </span>                :            :         /* as long as the bonus buf is held, the dnode will be held */
<span class="lineNum">     356 </span>        [<span class="branchCov" title="Branch 1 was taken 357271 times"> + </span><span class="branchCov" title="Branch 2 was taken 251710 times"> + </span>]:<span class="lineCov">     609003 :         if (refcount_add(&amp;db-&gt;db_holds, tag) == 1) {</span>
<span class="lineNum">     357 </span>        [<span class="branchNoCov" title="Branch 1 was not taken"> - </span><span class="branchCov" title="Branch 2 was taken 357273 times"> + </span>]:<span class="lineCov">     357271 :                 VERIFY(dnode_add_ref(dn, db));</span>
<span class="lineNum">     358 </span>                :<span class="lineCov">     357273 :                 atomic_inc_32(&amp;dn-&gt;dn_dbufs_count);</span>
<span class="lineNum">     359 </span>                :            :         }
<span class="lineNum">     360 </span>                :            : 
<span class="lineNum">     361 </span>                :            :         /*
<span class="lineNum">     362 </span>                :            :          * Wait to drop dn_struct_rwlock until after adding the bonus dbuf's
<span class="lineNum">     363 </span>                :            :          * hold and incrementing the dbuf count to ensure that dnode_move() sees
<span class="lineNum">     364 </span>                :            :          * a dnode hold for every dbuf.
<span class="lineNum">     365 </span>                :            :          */
<span class="lineNum">     366 </span>                :<span class="lineCov">     608989 :         rw_exit(&amp;dn-&gt;dn_struct_rwlock);</span>
<span class="lineNum">     367 </span>                :            : 
<span class="lineNum">     368 </span>                :<span class="lineCov">     609003 :         dnode_rele(dn, FTAG);</span>
<span class="lineNum">     369 </span>                :            : 
<span class="lineNum">     370 </span>                :<span class="lineCov">     608995 :         error = dbuf_read(db, NULL, db_flags);</span>
<span class="lineNum">     371 </span>        [<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 609001 times"> + </span>]:<span class="lineCov">     609001 :         if (error) {</span>
<span class="lineNum">     372 </span>                :<span class="lineNoCov">          0 :                 dnode_evict_bonus(dn);</span>
<span class="lineNum">     373 </span>                :<span class="lineNoCov">          0 :                 dbuf_rele(db, tag);</span>
<span class="lineNum">     374 </span>                :<span class="lineNoCov">          0 :                 *dbp = NULL;</span>
<span class="lineNum">     375 </span>                :<span class="lineNoCov">          0 :                 return (error);</span>
<span class="lineNum">     376 </span>                :            :         }
<span class="lineNum">     377 </span>                :            : 
<span class="lineNum">     378 </span>                :<span class="lineCov">     609001 :         *dbp = &amp;db-&gt;db;</span>
<span class="lineNum">     379 </span>                :<span class="lineCov">     609001 :         return (0);</span>
<span class="lineNum">     380 </span>                :            : }
<a name="381"><span class="lineNum">     381 </span>                :            : </a>
<span class="lineNum">     382 </span>                :            : int
<span class="lineNum">     383 </span>                :<span class="lineCov">     609009 : dmu_bonus_hold(objset_t *os, uint64_t obj, void *tag, dmu_buf_t **dbp)</span>
<span class="lineNum">     384 </span>                :            : {
<span class="lineNum">     385 </span>                :<span class="lineCov">     609009 :         return (dmu_bonus_hold_impl(os, obj, tag, DMU_READ_NO_PREFETCH, dbp));</span>
<span class="lineNum">     386 </span>                :            : }
<span class="lineNum">     387 </span>                :            : 
<span class="lineNum">     388 </span>                :            : /*
<span class="lineNum">     389 </span>                :            :  * returns ENOENT, EIO, or 0.
<span class="lineNum">     390 </span>                :            :  *
<span class="lineNum">     391 </span>                :            :  * This interface will allocate a blank spill dbuf when a spill blk
<span class="lineNum">     392 </span>                :            :  * doesn't already exist on the dnode.
<span class="lineNum">     393 </span>                :            :  *
<span class="lineNum">     394 </span>                :            :  * if you only want to find an already existing spill db, then
<span class="lineNum">     395 </span>                :            :  * dmu_spill_hold_existing() should be used.
<a name="396"><span class="lineNum">     396 </span>                :            :  */</a>
<span class="lineNum">     397 </span>                :            : int
<span class="lineNum">     398 </span>                :<span class="lineNoCov">          0 : dmu_spill_hold_by_dnode(dnode_t *dn, uint32_t flags, void *tag, dmu_buf_t **dbp)</span>
<span class="lineNum">     399 </span>                :            : {
<span class="lineNum">     400 </span>                :<span class="lineNoCov">          0 :         dmu_buf_impl_t *db = NULL;</span>
<span class="lineNum">     401 </span>                :            :         int err;
<span class="lineNum">     402 </span>                :            : 
<span class="lineNum">     403 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :         if ((flags &amp; DB_RF_HAVESTRUCT) == 0)</span>
<span class="lineNum">     404 </span>                :<span class="lineNoCov">          0 :                 rw_enter(&amp;dn-&gt;dn_struct_rwlock, RW_READER);</span>
<span class="lineNum">     405 </span>                :            : 
<span class="lineNum">     406 </span>                :<span class="lineNoCov">          0 :         db = dbuf_hold(dn, DMU_SPILL_BLKID, tag);</span>
<span class="lineNum">     407 </span>                :            : 
<span class="lineNum">     408 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :         if ((flags &amp; DB_RF_HAVESTRUCT) == 0)</span>
<span class="lineNum">     409 </span>                :<span class="lineNoCov">          0 :                 rw_exit(&amp;dn-&gt;dn_struct_rwlock);</span>
<span class="lineNum">     410 </span>                :            : 
<span class="lineNum">     411 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :         if (db == NULL) {</span>
<span class="lineNum">     412 </span>                :<span class="lineNoCov">          0 :                 *dbp = NULL;</span>
<span class="lineNum">     413 </span>                :<span class="lineNoCov">          0 :                 return (SET_ERROR(EIO));</span>
<span class="lineNum">     414 </span>                :            :         }
<span class="lineNum">     415 </span>                :<span class="lineNoCov">          0 :         err = dbuf_read(db, NULL, flags);</span>
<span class="lineNum">     416 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :         if (err == 0)</span>
<span class="lineNum">     417 </span>                :<span class="lineNoCov">          0 :                 *dbp = &amp;db-&gt;db;</span>
<span class="lineNum">     418 </span>                :            :         else {
<span class="lineNum">     419 </span>                :<span class="lineNoCov">          0 :                 dbuf_rele(db, tag);</span>
<span class="lineNum">     420 </span>                :<span class="lineNoCov">          0 :                 *dbp = NULL;</span>
<span class="lineNum">     421 </span>                :            :         }
<span class="lineNum">     422 </span>                :            :         return (err);
<span class="lineNum">     423 </span>                :            : }
<a name="424"><span class="lineNum">     424 </span>                :            : </a>
<span class="lineNum">     425 </span>                :            : int
<span class="lineNum">     426 </span>                :<span class="lineCov">         84 : dmu_spill_hold_existing(dmu_buf_t *bonus, void *tag, dmu_buf_t **dbp)</span>
<span class="lineNum">     427 </span>                :            : {
<span class="lineNum">     428 </span>                :<span class="lineCov">         84 :         dmu_buf_impl_t *db = (dmu_buf_impl_t *)bonus;</span>
<span class="lineNum">     429 </span>                :            :         dnode_t *dn;
<span class="lineNum">     430 </span>                :            :         int err;
<span class="lineNum">     431 </span>                :            : 
<span class="lineNum">     432 </span>                :<span class="lineCov">         84 :         DB_DNODE_ENTER(db);</span>
<span class="lineNum">     433 </span>                :<span class="lineCov">         84 :         dn = DB_DNODE(db);</span>
<span class="lineNum">     434 </span>                :            : 
<span class="lineNum">     435 </span>        [<span class="branchNoCov" title="Branch 1 was not taken"> - </span><span class="branchCov" title="Branch 2 was taken 84 times"> + </span>]:<span class="lineCov">         84 :         if (spa_version(dn-&gt;dn_objset-&gt;os_spa) &lt; SPA_VERSION_SA) {</span>
<span class="lineNum">     436 </span>                :<span class="lineNoCov">          0 :                 err = SET_ERROR(EINVAL);</span>
<span class="lineNum">     437 </span>                :            :         } else {
<span class="lineNum">     438 </span>                :<span class="lineCov">         84 :                 rw_enter(&amp;dn-&gt;dn_struct_rwlock, RW_READER);</span>
<span class="lineNum">     439 </span>                :            : 
<span class="lineNum">     440 </span>        [<span class="branchCov" title="Branch 0 was taken 84 times"> + </span><span class="branchNoCov" title="Branch 1 was not taken"> - </span>]:<span class="lineCov">         84 :                 if (!dn-&gt;dn_have_spill) {</span>
<span class="lineNum">     441 </span>                :<span class="lineCov">         84 :                         err = SET_ERROR(ENOENT);</span>
<span class="lineNum">     442 </span>                :            :                 } else {
<span class="lineNum">     443 </span>                :<span class="lineNoCov">          0 :                         err = dmu_spill_hold_by_dnode(dn,</span>
<span class="lineNum">     444 </span>                :            :                             DB_RF_HAVESTRUCT | DB_RF_CANFAIL, tag, dbp);
<span class="lineNum">     445 </span>                :            :                 }
<span class="lineNum">     446 </span>                :            : 
<span class="lineNum">     447 </span>                :<span class="lineCov">         84 :                 rw_exit(&amp;dn-&gt;dn_struct_rwlock);</span>
<span class="lineNum">     448 </span>                :            :         }
<span class="lineNum">     449 </span>                :            : 
<span class="lineNum">     450 </span>                :<span class="lineCov">         84 :         DB_DNODE_EXIT(db);</span>
<span class="lineNum">     451 </span>                :<span class="lineCov">         84 :         return (err);</span>
<span class="lineNum">     452 </span>                :            : }
<a name="453"><span class="lineNum">     453 </span>                :            : </a>
<span class="lineNum">     454 </span>                :            : int
<span class="lineNum">     455 </span>                :<span class="lineNoCov">          0 : dmu_spill_hold_by_bonus(dmu_buf_t *bonus, void *tag, dmu_buf_t **dbp)</span>
<span class="lineNum">     456 </span>                :            : {
<span class="lineNum">     457 </span>                :<span class="lineNoCov">          0 :         dmu_buf_impl_t *db = (dmu_buf_impl_t *)bonus;</span>
<span class="lineNum">     458 </span>                :            :         dnode_t *dn;
<span class="lineNum">     459 </span>                :            :         int err;
<span class="lineNum">     460 </span>                :            : 
<span class="lineNum">     461 </span>                :<span class="lineNoCov">          0 :         DB_DNODE_ENTER(db);</span>
<span class="lineNum">     462 </span>                :<span class="lineNoCov">          0 :         dn = DB_DNODE(db);</span>
<span class="lineNum">     463 </span>                :<span class="lineNoCov">          0 :         err = dmu_spill_hold_by_dnode(dn, DB_RF_CANFAIL, tag, dbp);</span>
<span class="lineNum">     464 </span>                :<span class="lineNoCov">          0 :         DB_DNODE_EXIT(db);</span>
<span class="lineNum">     465 </span>                :            : 
<span class="lineNum">     466 </span>                :<span class="lineNoCov">          0 :         return (err);</span>
<span class="lineNum">     467 </span>                :            : }
<span class="lineNum">     468 </span>                :            : 
<span class="lineNum">     469 </span>                :            : /*
<span class="lineNum">     470 </span>                :            :  * Note: longer-term, we should modify all of the dmu_buf_*() interfaces
<span class="lineNum">     471 </span>                :            :  * to take a held dnode rather than &lt;os, object&gt; -- the lookup is wasteful,
<span class="lineNum">     472 </span>                :            :  * and can induce severe lock contention when writing to several files
<span class="lineNum">     473 </span>                :            :  * whose dnodes are in the same block.
<a name="474"><span class="lineNum">     474 </span>                :            :  */</a>
<span class="lineNum">     475 </span>                :            : static int
<span class="lineNum">     476 </span>                :<span class="lineCov">     211813 : dmu_buf_hold_array_by_dnode(dnode_t *dn, uint64_t offset, uint64_t length,</span>
<span class="lineNum">     477 </span>                :            :     boolean_t read, void *tag, int *numbufsp, dmu_buf_t ***dbpp, uint32_t flags)
<span class="lineNum">     478 </span>                :            : {
<span class="lineNum">     479 </span>                :            :         dmu_buf_t **dbp;
<span class="lineNum">     480 </span>                :            :         uint64_t blkid, nblks, i;
<span class="lineNum">     481 </span>                :            :         uint32_t dbuf_flags;
<span class="lineNum">     482 </span>                :            :         int err;
<span class="lineNum">     483 </span>                :            :         zio_t *zio;
<span class="lineNum">     484 </span>                :            : 
<span class="lineNum">     485 </span>        [<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 211813 times"> + </span>]:<span class="lineCov">     211813 :         ASSERT(length &lt;= DMU_MAX_ACCESS);</span>
<span class="lineNum">     486 </span>                :            : 
<span class="lineNum">     487 </span>                :            :         /*
<span class="lineNum">     488 </span>                :            :          * Note: We directly notify the prefetch code of this read, so that
<span class="lineNum">     489 </span>                :            :          * we can tell it about the multi-block read.  dbuf_read() only knows
<span class="lineNum">     490 </span>                :            :          * about the one block it is accessing.
<span class="lineNum">     491 </span>                :            :          */
<span class="lineNum">     492 </span>                :<span class="lineCov">     211813 :         dbuf_flags = DB_RF_CANFAIL | DB_RF_NEVERWAIT | DB_RF_HAVESTRUCT |</span>
<span class="lineNum">     493 </span>                :            :             DB_RF_NOPREFETCH;
<span class="lineNum">     494 </span>                :            : 
<span class="lineNum">     495 </span>                :<span class="lineCov">     211813 :         rw_enter(&amp;dn-&gt;dn_struct_rwlock, RW_READER);</span>
<span class="lineNum">     496 </span>        [<span class="branchCov" title="Branch 0 was taken 211822 times"> + </span><span class="branchNoCov" title="Branch 1 was not taken"> - </span>]:<span class="lineCov">     211822 :         if (dn-&gt;dn_datablkshift) {</span>
<span class="lineNum">     497 </span>                :<span class="lineCov">     211822 :                 int blkshift = dn-&gt;dn_datablkshift;</span>
<span class="lineNum">     498 </span>                :<span class="lineCov">     211822 :                 nblks = (P2ROUNDUP(offset + length, 1ULL &lt;&lt; blkshift) -</span>
<span class="lineNum">     499 </span>                :<span class="lineCov">     211822 :                     P2ALIGN(offset, 1ULL &lt;&lt; blkshift)) &gt;&gt; blkshift;</span>
<span class="lineNum">     500 </span>                :            :         } else {
<span class="lineNum">     501 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :                 if (offset + length &gt; dn-&gt;dn_datablksz) {</span>
<span class="lineNum">     502 </span>                :<span class="lineNoCov">          0 :                         zfs_panic_recover(&quot;zfs: accessing past end of object &quot;</span>
<span class="lineNum">     503 </span>                :            :                             &quot;%llx/%llx (size=%u access=%llu+%llu)&quot;,
<span class="lineNum">     504 </span>                :<span class="lineNoCov">          0 :                             (longlong_t)dn-&gt;dn_objset-&gt;</span>
<span class="lineNum">     505 </span>                :<span class="lineNoCov">          0 :                             os_dsl_dataset-&gt;ds_object,</span>
<span class="lineNum">     506 </span>                :<span class="lineNoCov">          0 :                             (longlong_t)dn-&gt;dn_object, dn-&gt;dn_datablksz,</span>
<span class="lineNum">     507 </span>                :            :                             (longlong_t)offset, (longlong_t)length);
<span class="lineNum">     508 </span>                :<span class="lineNoCov">          0 :                         rw_exit(&amp;dn-&gt;dn_struct_rwlock);</span>
<span class="lineNum">     509 </span>                :<span class="lineNoCov">          0 :                         return (SET_ERROR(EIO));</span>
<span class="lineNum">     510 </span>                :            :                 }
<span class="lineNum">     511 </span>                :            :                 nblks = 1;
<span class="lineNum">     512 </span>                :            :         }
<span class="lineNum">     513 </span>                :<span class="lineCov">     211822 :         dbp = kmem_zalloc(sizeof (dmu_buf_t *) * nblks, KM_SLEEP);</span>
<span class="lineNum">     514 </span>                :            : 
<span class="lineNum">     515 </span>                :<span class="lineCov">     211804 :         zio = zio_root(dn-&gt;dn_objset-&gt;os_spa, NULL, NULL, ZIO_FLAG_CANFAIL);</span>
<span class="lineNum">     516 </span>                :<span class="lineCov">     211812 :         blkid = dbuf_whichblock(dn, 0, offset);</span>
<span class="lineNum">     517 </span>        [<span class="branchCov" title="Branch 1 was taken 269906 times"> + </span><span class="branchCov" title="Branch 2 was taken 211818 times"> + </span>]:<span class="lineCov">     481732 :         for (i = 0; i &lt; nblks; i++) {</span>
<span class="lineNum">     518 </span>                :<span class="lineCov">     269906 :                 dmu_buf_impl_t *db = dbuf_hold(dn, blkid + i, tag);</span>
<span class="lineNum">     519 </span>        [<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 269915 times"> + </span>]:<span class="lineCov">     269915 :                 if (db == NULL) {</span>
<span class="lineNum">     520 </span>                :<span class="lineNoCov">          0 :                         rw_exit(&amp;dn-&gt;dn_struct_rwlock);</span>
<span class="lineNum">     521 </span>                :<span class="lineNoCov">          0 :                         dmu_buf_rele_array(dbp, nblks, tag);</span>
<span class="lineNum">     522 </span>                :<span class="lineNoCov">          0 :                         zio_nowait(zio);</span>
<span class="lineNum">     523 </span>                :<span class="lineNoCov">          0 :                         return (SET_ERROR(EIO));</span>
<span class="lineNum">     524 </span>                :            :                 }
<span class="lineNum">     525 </span>                :            : 
<span class="lineNum">     526 </span>                :            :                 /* initiate async i/o */
<span class="lineNum">     527 </span>        [<span class="branchCov" title="Branch 0 was taken 102422 times"> + </span><span class="branchCov" title="Branch 1 was taken 167493 times"> + </span>]:<span class="lineCov">     269915 :                 if (read)</span>
<span class="lineNum">     528 </span>                :<span class="lineCov">     102422 :                         (void) dbuf_read(db, zio, dbuf_flags);</span>
<span class="lineNum">     529 </span>                :<span class="lineCov">     269920 :                 dbp[i] = &amp;db-&gt;db;</span>
<span class="lineNum">     530 </span>                :            :         }
<span class="lineNum">     531 </span>                :            : 
<span class="lineNum">     532 </span>[<span class="branchCov" title="Branch 0 was taken 194915 times"> + </span><span class="branchCov" title="Branch 1 was taken 16903 times"> + </span>][<span class="branchCov" title="Branch 2 was taken 194915 times"> + </span><span class="branchNoCov" title="Branch 3 was not taken"> - </span>]:<span class="lineCov">     211818 :         if ((flags &amp; DMU_READ_NO_PREFETCH) == 0 &amp;&amp;</span>
<span class="lineNum">     533 </span>        [<span class="branchCov" title="Branch 0 was taken 194819 times"> + </span><span class="branchCov" title="Branch 1 was taken 96 times"> + </span>]:<span class="lineCov">     194915 :             DNODE_META_IS_CACHEABLE(dn) &amp;&amp; length &lt;= zfetch_array_rd_sz) {</span>
<span class="lineNum">     534 </span>                :<span class="lineCov">     194819 :                 dmu_zfetch(&amp;dn-&gt;dn_zfetch, blkid, nblks,</span>
<span class="lineNum">     535 </span>[<span class="branchCov" title="Branch 0 was taken 49603 times"> + </span><span class="branchCov" title="Branch 1 was taken 145216 times"> + </span>][<span class="branchNoCov" title="Branch 2 was not taken"> - </span><span class="branchCov" title="Branch 3 was taken 49603 times"> + </span>]:<span class="lineCov">     194819 :                     read &amp;&amp; DNODE_IS_CACHEABLE(dn));</span>
<span class="lineNum">         </span>[<span class="branchNoExec" title="Branch 4 was not executed"> # </span><span class="branchNoExec" title="Branch 5 was not executed"> # </span>][<span class="branchNoExec" title="Branch 6 was not executed"> # </span><span class="branchNoExec" title="Branch 7 was not executed"> # </span>]
<span class="lineNum">         </span>     [<span class="branchNoExec" title="Branch 8 was not executed"> # </span><span class="branchNoExec" title="Branch 9 was not executed"> # </span><span class="branchNoCov" title="Branch 10 was not taken"> - </span>]
<span class="lineNum">     536 </span>                :            :         }
<span class="lineNum">     537 </span>                :<span class="lineCov">     211827 :         rw_exit(&amp;dn-&gt;dn_struct_rwlock);</span>
<span class="lineNum">     538 </span>                :            : 
<span class="lineNum">     539 </span>                :            :         /* wait for async i/o */
<span class="lineNum">     540 </span>                :<span class="lineCov">     211820 :         err = zio_wait(zio);</span>
<span class="lineNum">     541 </span>        [<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 211817 times"> + </span>]:<span class="lineCov">     211817 :         if (err) {</span>
<span class="lineNum">     542 </span>                :<span class="lineNoCov">          0 :                 dmu_buf_rele_array(dbp, nblks, tag);</span>
<span class="lineNum">     543 </span>                :<span class="lineNoCov">          0 :                 return (err);</span>
<span class="lineNum">     544 </span>                :            :         }
<span class="lineNum">     545 </span>                :            : 
<span class="lineNum">     546 </span>                :            :         /* wait for other io to complete */
<span class="lineNum">     547 </span>        [<span class="branchCov" title="Branch 0 was taken 66598 times"> + </span><span class="branchCov" title="Branch 1 was taken 145219 times"> + </span>]:<span class="lineCov">     211817 :         if (read) {</span>
<span class="lineNum">     548 </span>        [<span class="branchCov" title="Branch 0 was taken 102422 times"> + </span><span class="branchCov" title="Branch 1 was taken 66599 times"> + </span>]:<span class="lineCov">     169021 :                 for (i = 0; i &lt; nblks; i++) {</span>
<span class="lineNum">     549 </span>                :<span class="lineCov">     102422 :                         dmu_buf_impl_t *db = (dmu_buf_impl_t *)dbp[i];</span>
<span class="lineNum">     550 </span>                :<span class="lineCov">     102422 :                         mutex_enter(&amp;db-&gt;db_mtx);</span>
<span class="lineNum">     551 </span>        [<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 102421 times"> + </span>]:<span class="lineCov">     102421 :                         while (db-&gt;db_state == DB_READ ||</span>
<span class="lineNum">     552 </span>                :            :                             db-&gt;db_state == DB_FILL)
<span class="lineNum">     553 </span>                :<span class="lineNoCov">          0 :                                 cv_wait(&amp;db-&gt;db_changed, &amp;db-&gt;db_mtx);</span>
<span class="lineNum">     554 </span>        [<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 102421 times"> + </span>]:<span class="lineCov">     102421 :                         if (db-&gt;db_state == DB_UNCACHED)</span>
<span class="lineNum">     555 </span>                :<span class="lineNoCov">          0 :                                 err = SET_ERROR(EIO);</span>
<span class="lineNum">     556 </span>                :<span class="lineCov">     102421 :                         mutex_exit(&amp;db-&gt;db_mtx);</span>
<span class="lineNum">     557 </span>        [<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 102423 times"> + </span>]:<span class="lineCov">     102423 :                         if (err) {</span>
<span class="lineNum">     558 </span>                :<span class="lineNoCov">          0 :                                 dmu_buf_rele_array(dbp, nblks, tag);</span>
<span class="lineNum">     559 </span>                :<span class="lineNoCov">          0 :                                 return (err);</span>
<span class="lineNum">     560 </span>                :            :                         }
<span class="lineNum">     561 </span>                :            :                 }
<span class="lineNum">     562 </span>                :            :         }
<span class="lineNum">     563 </span>                :            : 
<span class="lineNum">     564 </span>                :<span class="lineCov">     211818 :         *numbufsp = nblks;</span>
<span class="lineNum">     565 </span>                :<span class="lineCov">     211818 :         *dbpp = dbp;</span>
<span class="lineNum">     566 </span>                :<span class="lineCov">     211818 :         return (0);</span>
<span class="lineNum">     567 </span>                :            : }
<a name="568"><span class="lineNum">     568 </span>                :            : </a>
<span class="lineNum">     569 </span>                :            : static int
<span class="lineNum">     570 </span>                :<span class="lineCov">     145217 : dmu_buf_hold_array(objset_t *os, uint64_t object, uint64_t offset,</span>
<span class="lineNum">     571 </span>                :            :     uint64_t length, int read, void *tag, int *numbufsp, dmu_buf_t ***dbpp)
<span class="lineNum">     572 </span>                :            : {
<span class="lineNum">     573 </span>                :            :         dnode_t *dn;
<span class="lineNum">     574 </span>                :            :         int err;
<span class="lineNum">     575 </span>                :            : 
<span class="lineNum">     576 </span>                :<span class="lineCov">     145217 :         err = dnode_hold(os, object, FTAG, &amp;dn);</span>
<span class="lineNum">     577 </span>        [<span class="branchCov" title="Branch 0 was taken 145223 times"> + </span><span class="branchNoCov" title="Branch 1 was not taken"> - </span>]:<span class="lineCov">     145223 :         if (err)</span>
<span class="lineNum">     578 </span>                :            :                 return (err);
<span class="lineNum">     579 </span>                :            : 
<span class="lineNum">     580 </span>                :<span class="lineCov">     145223 :         err = dmu_buf_hold_array_by_dnode(dn, offset, length, read, tag,</span>
<span class="lineNum">     581 </span>                :            :             numbufsp, dbpp, DMU_READ_PREFETCH);
<span class="lineNum">     582 </span>                :            : 
<span class="lineNum">     583 </span>                :<span class="lineCov">     145221 :         dnode_rele(dn, FTAG);</span>
<span class="lineNum">     584 </span>                :            : 
<span class="lineNum">     585 </span>                :<span class="lineCov">     145219 :         return (err);</span>
<span class="lineNum">     586 </span>                :            : }
<a name="587"><span class="lineNum">     587 </span>                :            : </a>
<span class="lineNum">     588 </span>                :            : int
<span class="lineNum">     589 </span>                :<span class="lineNoCov">          0 : dmu_buf_hold_array_by_bonus(dmu_buf_t *db_fake, uint64_t offset,</span>
<span class="lineNum">     590 </span>                :            :     uint64_t length, boolean_t read, void *tag, int *numbufsp,
<span class="lineNum">     591 </span>                :            :     dmu_buf_t ***dbpp)
<span class="lineNum">     592 </span>                :            : {
<span class="lineNum">     593 </span>                :<span class="lineNoCov">          0 :         dmu_buf_impl_t *db = (dmu_buf_impl_t *)db_fake;</span>
<span class="lineNum">     594 </span>                :            :         dnode_t *dn;
<span class="lineNum">     595 </span>                :            :         int err;
<span class="lineNum">     596 </span>                :            : 
<span class="lineNum">     597 </span>                :<span class="lineNoCov">          0 :         DB_DNODE_ENTER(db);</span>
<span class="lineNum">     598 </span>                :<span class="lineNoCov">          0 :         dn = DB_DNODE(db);</span>
<span class="lineNum">     599 </span>                :<span class="lineNoCov">          0 :         err = dmu_buf_hold_array_by_dnode(dn, offset, length, read, tag,</span>
<span class="lineNum">     600 </span>                :            :             numbufsp, dbpp, DMU_READ_PREFETCH);
<span class="lineNum">     601 </span>                :<span class="lineNoCov">          0 :         DB_DNODE_EXIT(db);</span>
<span class="lineNum">     602 </span>                :            : 
<span class="lineNum">     603 </span>                :<span class="lineNoCov">          0 :         return (err);</span>
<span class="lineNum">     604 </span>                :            : }
<a name="605"><span class="lineNum">     605 </span>                :            : </a>
<span class="lineNum">     606 </span>                :            : void
<span class="lineNum">     607 </span>                :<span class="lineCov">     211809 : dmu_buf_rele_array(dmu_buf_t **dbp_fake, int numbufs, void *tag)</span>
<span class="lineNum">     608 </span>                :            : {
<span class="lineNum">     609 </span>                :            :         int i;
<span class="lineNum">     610 </span>                :<span class="lineCov">     211809 :         dmu_buf_impl_t **dbp = (dmu_buf_impl_t **)dbp_fake;</span>
<span class="lineNum">     611 </span>                :            : 
<span class="lineNum">     612 </span>        [<span class="branchCov" title="Branch 0 was taken 211809 times"> + </span><span class="branchNoCov" title="Branch 1 was not taken"> - </span>]:<span class="lineCov">     211809 :         if (numbufs == 0)</span>
<span class="lineNum">     613 </span>                :            :                 return;
<span class="lineNum">     614 </span>                :            : 
<span class="lineNum">     615 </span>        [<span class="branchCov" title="Branch 0 was taken 269907 times"> + </span><span class="branchCov" title="Branch 1 was taken 211822 times"> + </span>]:<span class="lineCov">     481729 :         for (i = 0; i &lt; numbufs; i++) {</span>
<span class="lineNum">     616 </span>        [<span class="branchCov" title="Branch 0 was taken 269907 times"> + </span><span class="branchNoCov" title="Branch 1 was not taken"> - </span>]:<span class="lineCov">     269907 :                 if (dbp[i])</span>
<span class="lineNum">     617 </span>                :<span class="lineCov">     269907 :                         dbuf_rele(dbp[i], tag);</span>
<span class="lineNum">     618 </span>                :            :         }
<span class="lineNum">     619 </span>                :            : 
<span class="lineNum">     620 </span>                :<span class="lineCov">     211822 :         kmem_free(dbp, sizeof (dmu_buf_t *) * numbufs);</span>
<span class="lineNum">     621 </span>                :            : }
<span class="lineNum">     622 </span>                :            : 
<span class="lineNum">     623 </span>                :            : /*
<span class="lineNum">     624 </span>                :            :  * Issue prefetch i/os for the given blocks.  If level is greater than 0, the
<span class="lineNum">     625 </span>                :            :  * indirect blocks prefeteched will be those that point to the blocks containing
<span class="lineNum">     626 </span>                :            :  * the data starting at offset, and continuing to offset + len.
<span class="lineNum">     627 </span>                :            :  *
<span class="lineNum">     628 </span>                :            :  * Note that if the indirect blocks above the blocks being prefetched are not
<span class="lineNum">     629 </span>                :            :  * in cache, they will be asychronously read in.
<a name="630"><span class="lineNum">     630 </span>                :            :  */</a>
<span class="lineNum">     631 </span>                :            : void
<span class="lineNum">     632 </span>                :<span class="lineCov">       3991 : dmu_prefetch(objset_t *os, uint64_t object, int64_t level, uint64_t offset,</span>
<span class="lineNum">     633 </span>                :            :     uint64_t len, zio_priority_t pri)
<span class="lineNum">     634 </span>                :            : {
<span class="lineNum">     635 </span>                :            :         dnode_t *dn;
<span class="lineNum">     636 </span>                :            :         uint64_t blkid;
<span class="lineNum">     637 </span>                :            :         int nblks, err;
<span class="lineNum">     638 </span>                :            : 
<span class="lineNum">     639 </span>        [<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 3991 times"> + </span>]:<span class="lineCov">       3991 :         if (len == 0) {  /* they're interested in the bonus buffer */</span>
<span class="lineNum">     640 </span>                :<span class="lineNoCov">          0 :                 dn = DMU_META_DNODE(os);</span>
<span class="lineNum">     641 </span>                :            : 
<span class="lineNum">     642 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :                 if (object == 0 || object &gt;= DN_MAX_OBJECT)</span>
<span class="lineNum">     643 </span>                :<span class="lineCov">         38 :                         return;</span>
<span class="lineNum">     644 </span>                :            : 
<span class="lineNum">     645 </span>                :<span class="lineNoCov">          0 :                 rw_enter(&amp;dn-&gt;dn_struct_rwlock, RW_READER);</span>
<span class="lineNum">     646 </span>                :<span class="lineNoCov">          0 :                 blkid = dbuf_whichblock(dn, level,</span>
<span class="lineNum">     647 </span>                :            :                     object * sizeof (dnode_phys_t));
<span class="lineNum">     648 </span>                :<span class="lineNoCov">          0 :                 dbuf_prefetch(dn, level, blkid, pri, 0);</span>
<span class="lineNum">     649 </span>                :<span class="lineNoCov">          0 :                 rw_exit(&amp;dn-&gt;dn_struct_rwlock);</span>
<span class="lineNum">     650 </span>                :<span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     651 </span>                :            :         }
<span class="lineNum">     652 </span>                :            : 
<span class="lineNum">     653 </span>                :            :         /*
<span class="lineNum">     654 </span>                :            :          * XXX - Note, if the dnode for the requested object is not
<span class="lineNum">     655 </span>                :            :          * already cached, we will do a *synchronous* read in the
<span class="lineNum">     656 </span>                :            :          * dnode_hold() call.  The same is true for any indirects.
<span class="lineNum">     657 </span>                :            :          */
<span class="lineNum">     658 </span>                :<span class="lineCov">       3991 :         err = dnode_hold(os, object, FTAG, &amp;dn);</span>
<span class="lineNum">     659 </span>        [<span class="branchCov" title="Branch 0 was taken 3953 times"> + </span><span class="branchCov" title="Branch 1 was taken 38 times"> + </span>]:<span class="lineCov">       3991 :         if (err != 0)</span>
<span class="lineNum">     660 </span>                :            :                 return;
<span class="lineNum">     661 </span>                :            : 
<span class="lineNum">     662 </span>                :<span class="lineCov">       3953 :         rw_enter(&amp;dn-&gt;dn_struct_rwlock, RW_READER);</span>
<span class="lineNum">     663 </span>                :            :         /*
<span class="lineNum">     664 </span>                :            :          * offset + len - 1 is the last byte we want to prefetch for, and offset
<span class="lineNum">     665 </span>                :            :          * is the first.  Then dbuf_whichblk(dn, level, off + len - 1) is the
<span class="lineNum">     666 </span>                :            :          * last block we want to prefetch, and dbuf_whichblock(dn, level,
<span class="lineNum">     667 </span>                :            :          * offset)  is the first.  Then the number we need to prefetch is the
<span class="lineNum">     668 </span>                :            :          * last - first + 1.
<span class="lineNum">     669 </span>                :            :          */
<span class="lineNum">     670 </span>[<span class="branchCov" title="Branch 0 was taken 3953 times"> + </span><span class="branchNoCov" title="Branch 1 was not taken"> - </span>][<span class="branchCov" title="Branch 2 was taken 3931 times"> + </span><span class="branchCov" title="Branch 3 was taken 22 times"> + </span>]:<span class="lineCov">       3953 :         if (level &gt; 0 || dn-&gt;dn_datablkshift != 0) {</span>
<span class="lineNum">     671 </span>                :<span class="lineCov">       7862 :                 nblks = dbuf_whichblock(dn, level, offset + len - 1) -</span>
<span class="lineNum">     672 </span>                :<span class="lineCov">       3931 :                     dbuf_whichblock(dn, level, offset) + 1;</span>
<span class="lineNum">     673 </span>                :            :         } else {
<span class="lineNum">     674 </span>                :<span class="lineCov">         22 :                 nblks = (offset &lt; dn-&gt;dn_datablksz);</span>
<span class="lineNum">     675 </span>                :            :         }
<span class="lineNum">     676 </span>                :            : 
<span class="lineNum">     677 </span>        [<span class="branchCov" title="Branch 0 was taken 3953 times"> + </span><span class="branchNoCov" title="Branch 1 was not taken"> - </span>]:<span class="lineCov">       3953 :         if (nblks != 0) {</span>
<span class="lineNum">     678 </span>                :            :                 int i;
<span class="lineNum">     679 </span>                :            : 
<span class="lineNum">     680 </span>                :<span class="lineCov">       3953 :                 blkid = dbuf_whichblock(dn, level, offset);</span>
<span class="lineNum">     681 </span>        [<span class="branchCov" title="Branch 1 was taken 4049991 times"> + </span><span class="branchCov" title="Branch 2 was taken 3953 times"> + </span>]:<span class="lineCov">    4053944 :                 for (i = 0; i &lt; nblks; i++)</span>
<span class="lineNum">     682 </span>                :<span class="lineCov">    4049991 :                         dbuf_prefetch(dn, level, blkid + i, pri, 0);</span>
<span class="lineNum">     683 </span>                :            :         }
<span class="lineNum">     684 </span>                :            : 
<span class="lineNum">     685 </span>                :<span class="lineCov">       3953 :         rw_exit(&amp;dn-&gt;dn_struct_rwlock);</span>
<span class="lineNum">     686 </span>                :            : 
<span class="lineNum">     687 </span>                :<span class="lineCov">       3953 :         dnode_rele(dn, FTAG);</span>
<span class="lineNum">     688 </span>                :            : }
<span class="lineNum">     689 </span>                :            : 
<span class="lineNum">     690 </span>                :            : /*
<span class="lineNum">     691 </span>                :            :  * Get the next &quot;chunk&quot; of file data to free.  We traverse the file from
<span class="lineNum">     692 </span>                :            :  * the end so that the file gets shorter over time (if we crashes in the
<span class="lineNum">     693 </span>                :            :  * middle, this will leave us in a better state).  We find allocated file
<span class="lineNum">     694 </span>                :            :  * data by simply searching the allocated level 1 indirects.
<span class="lineNum">     695 </span>                :            :  *
<span class="lineNum">     696 </span>                :            :  * On input, *start should be the first offset that does not need to be
<span class="lineNum">     697 </span>                :            :  * freed (e.g. &quot;offset + length&quot;).  On return, *start will be the first
<span class="lineNum">     698 </span>                :            :  * offset that should be freed.
<a name="699"><span class="lineNum">     699 </span>                :            :  */</a>
<span class="lineNum">     700 </span>                :            : static int
<span class="lineNum">     701 </span>                :<span class="lineNoCov">          0 : get_next_chunk(dnode_t *dn, uint64_t *start, uint64_t minimum)</span>
<span class="lineNum">     702 </span>                :            : {
<span class="lineNum">     703 </span>                :<span class="lineNoCov">          0 :         uint64_t maxblks = DMU_MAX_ACCESS &gt;&gt; (dn-&gt;dn_indblkshift + 1);</span>
<span class="lineNum">     704 </span>                :            :         /* bytes of data covered by a level-1 indirect block */
<span class="lineNum">     705 </span>                :<span class="lineNoCov">          0 :         uint64_t iblkrange =</span>
<span class="lineNum">     706 </span>                :<span class="lineNoCov">          0 :             dn-&gt;dn_datablksz * EPB(dn-&gt;dn_indblkshift, SPA_BLKPTRSHIFT);</span>
<span class="lineNum">     707 </span>                :            :         uint64_t blks;
<span class="lineNum">     708 </span>                :            : 
<span class="lineNum">     709 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :         ASSERT3U(minimum, &lt;=, *start);</span>
<span class="lineNum">     710 </span>                :            : 
<span class="lineNum">     711 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :         if (*start - minimum &lt;= iblkrange * maxblks) {</span>
<span class="lineNum">     712 </span>                :<span class="lineNoCov">          0 :                 *start = minimum;</span>
<span class="lineNum">     713 </span>                :<span class="lineNoCov">          0 :                 return (0);</span>
<span class="lineNum">     714 </span>                :            :         }
<span class="lineNum">     715 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :         ASSERT(ISP2(iblkrange));</span>
<span class="lineNum">     716 </span>                :            : 
<span class="lineNum">     717 </span>[<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>][<span class="branchNoExec" title="Branch 2 was not executed"> # </span><span class="branchNoExec" title="Branch 3 was not executed"> # </span>]:<span class="lineNoCov">          0 :         for (blks = 0; *start &gt; minimum &amp;&amp; blks &lt; maxblks; blks++) {</span>
<span class="lineNum">     718 </span>                :            :                 int err;
<span class="lineNum">     719 </span>                :            : 
<span class="lineNum">     720 </span>                :            :                 /*
<span class="lineNum">     721 </span>                :            :                  * dnode_next_offset(BACKWARDS) will find an allocated L1
<span class="lineNum">     722 </span>                :            :                  * indirect block at or before the input offset.  We must
<span class="lineNum">     723 </span>                :            :                  * decrement *start so that it is at the end of the region
<span class="lineNum">     724 </span>                :            :                  * to search.
<span class="lineNum">     725 </span>                :            :                  */
<span class="lineNum">     726 </span>                :<span class="lineNoCov">          0 :                 (*start)--;</span>
<span class="lineNum">     727 </span>                :<span class="lineNoCov">          0 :                 err = dnode_next_offset(dn,</span>
<span class="lineNum">     728 </span>                :            :                     DNODE_FIND_BACKWARDS, start, 2, 1, 0);
<span class="lineNum">     729 </span>                :            : 
<span class="lineNum">     730 </span>                :            :                 /* if there are no indirect blocks before start, we are done */
<span class="lineNum">     731 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :                 if (err == ESRCH) {</span>
<span class="lineNum">     732 </span>                :<span class="lineNoCov">          0 :                         *start = minimum;</span>
<span class="lineNum">     733 </span>                :<span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     734 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :                 } else if (err != 0) {</span>
<span class="lineNum">     735 </span>                :            :                         return (err);
<span class="lineNum">     736 </span>                :            :                 }
<span class="lineNum">     737 </span>                :            : 
<span class="lineNum">     738 </span>                :            :                 /* set start to the beginning of this L1 indirect */
<span class="lineNum">     739 </span>                :<span class="lineNoCov">          0 :                 *start = P2ALIGN(*start, iblkrange);</span>
<span class="lineNum">     740 </span>                :            :         }
<span class="lineNum">     741 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :         if (*start &lt; minimum)</span>
<span class="lineNum">     742 </span>                :<span class="lineNoCov">          0 :                 *start = minimum;</span>
<span class="lineNum">     743 </span>                :            :         return (0);
<span class="lineNum">     744 </span>                :            : }
<span class="lineNum">     745 </span>                :            : 
<span class="lineNum">     746 </span>                :            : /*
<span class="lineNum">     747 </span>                :            :  * If this objset is of type OST_ZFS return true if vfs's unmounted flag is set,
<span class="lineNum">     748 </span>                :            :  * otherwise return false.
<span class="lineNum">     749 </span>                :            :  * Used below in dmu_free_long_range_impl() to enable abort when unmounting
<span class="lineNum">     750 </span>                :            :  */
<a name="751"><span class="lineNum">     751 </span>                :            : /*ARGSUSED*/</a>
<span class="lineNum">     752 </span>                :            : static boolean_t
<span class="lineNum">     753 </span>                :<span class="lineNoCov">          0 : dmu_objset_zfs_unmounting(objset_t *os)</span>
<span class="lineNum">     754 </span>                :            : {
<span class="lineNum">     755 </span>                :            : #ifdef _KERNEL
<span class="lineNum">     756 </span>                :            :         if (dmu_objset_type(os) == DMU_OST_ZFS)
<span class="lineNum">     757 </span>                :            :                 return (zfs_get_vfs_flag_unmounted(os));
<span class="lineNum">     758 </span>                :            : #endif
<span class="lineNum">     759 </span>                :<span class="lineNoCov">          0 :         return (B_FALSE);</span>
<span class="lineNum">     760 </span>                :            : }
<a name="761"><span class="lineNum">     761 </span>                :            : </a>
<span class="lineNum">     762 </span>                :            : static int
<span class="lineNum">     763 </span>                :<span class="lineNoCov">          0 : dmu_free_long_range_impl(objset_t *os, dnode_t *dn, uint64_t offset,</span>
<span class="lineNum">     764 </span>                :            :     uint64_t length)
<span class="lineNum">     765 </span>                :            : {
<span class="lineNum">     766 </span>                :            :         uint64_t object_size;
<span class="lineNum">     767 </span>                :            :         int err;
<span class="lineNum">     768 </span>                :            :         uint64_t dirty_frees_threshold;
<span class="lineNum">     769 </span>                :<span class="lineNoCov">          0 :         dsl_pool_t *dp = dmu_objset_pool(os);</span>
<span class="lineNum">     770 </span>                :            :         int t;
<span class="lineNum">     771 </span>                :            : 
<span class="lineNum">     772 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :         if (dn == NULL)</span>
<span class="lineNum">     773 </span>                :<span class="lineNoCov">          0 :                 return (SET_ERROR(EINVAL));</span>
<span class="lineNum">     774 </span>                :            : 
<span class="lineNum">     775 </span>                :<span class="lineNoCov">          0 :         object_size = (dn-&gt;dn_maxblkid + 1) * dn-&gt;dn_datablksz;</span>
<span class="lineNum">     776 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :         if (offset &gt;= object_size)</span>
<span class="lineNum">     777 </span>                :            :                 return (0);
<span class="lineNum">     778 </span>                :            : 
<span class="lineNum">     779 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :         if (zfs_per_txg_dirty_frees_percent &lt;= 100)</span>
<span class="lineNum">     780 </span>                :<span class="lineNoCov">          0 :                 dirty_frees_threshold =</span>
<span class="lineNum">     781 </span>                :<span class="lineNoCov">          0 :                     zfs_per_txg_dirty_frees_percent * zfs_dirty_data_max / 100;</span>
<span class="lineNum">     782 </span>                :            :         else
<span class="lineNum">     783 </span>                :<span class="lineNoCov">          0 :                 dirty_frees_threshold = zfs_dirty_data_max / 4;</span>
<span class="lineNum">     784 </span>                :            : 
<span class="lineNum">     785 </span>[<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>][<span class="branchNoExec" title="Branch 2 was not executed"> # </span><span class="branchNoExec" title="Branch 3 was not executed"> # </span>]:<span class="lineNoCov">          0 :         if (length == DMU_OBJECT_END || offset + length &gt; object_size)</span>
<span class="lineNum">     786 </span>                :<span class="lineNoCov">          0 :                 length = object_size - offset;</span>
<span class="lineNum">     787 </span>                :            : 
<span class="lineNum">     788 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :         while (length != 0) {</span>
<span class="lineNum">     789 </span>                :            :                 uint64_t chunk_end, chunk_begin, chunk_len;
<span class="lineNum">     790 </span>                :<span class="lineNoCov">          0 :                 uint64_t long_free_dirty_all_txgs = 0;</span>
<span class="lineNum">     791 </span>                :            :                 dmu_tx_t *tx;
<span class="lineNum">     792 </span>                :            : 
<span class="lineNum">     793 </span>        [<span class="branchNoExec" title="Branch 1 was not executed"> # </span><span class="branchNoExec" title="Branch 2 was not executed"> # </span>]:<span class="lineNoCov">          0 :                 if (dmu_objset_zfs_unmounting(dn-&gt;dn_objset))</span>
<span class="lineNum">     794 </span>                :<span class="lineNoCov">          0 :                         return (SET_ERROR(EINTR));</span>
<span class="lineNum">     795 </span>                :            : 
<span class="lineNum">     796 </span>                :<span class="lineNoCov">          0 :                 chunk_end = chunk_begin = offset + length;</span>
<span class="lineNum">     797 </span>                :            : 
<span class="lineNum">     798 </span>                :            :                 /* move chunk_begin backwards to the beginning of this chunk */
<span class="lineNum">     799 </span>                :<span class="lineNoCov">          0 :                 err = get_next_chunk(dn, &amp;chunk_begin, offset);</span>
<span class="lineNum">     800 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :                 if (err)</span>
<span class="lineNum">     801 </span>                :            :                         return (err);
<span class="lineNum">     802 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :                 ASSERT3U(chunk_begin, &gt;=, offset);</span>
<span class="lineNum">     803 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :                 ASSERT3U(chunk_begin, &lt;=, chunk_end);</span>
<span class="lineNum">     804 </span>                :            : 
<span class="lineNum">     805 </span>                :<span class="lineNoCov">          0 :                 chunk_len = chunk_end - chunk_begin;</span>
<span class="lineNum">     806 </span>                :            : 
<span class="lineNum">     807 </span>                :<span class="lineNoCov">          0 :                 mutex_enter(&amp;dp-&gt;dp_lock);</span>
<span class="lineNum">     808 </span>        [<span class="branchNoExec" title="Branch 1 was not executed"> # </span><span class="branchNoExec" title="Branch 2 was not executed"> # </span>]:<span class="lineNoCov">          0 :                 for (t = 0; t &lt; TXG_SIZE; t++) {</span>
<span class="lineNum">     809 </span>                :<span class="lineNoCov">          0 :                         long_free_dirty_all_txgs +=</span>
<span class="lineNum">     810 </span>                :<span class="lineNoCov">          0 :                             dp-&gt;dp_long_free_dirty_pertxg[t];</span>
<span class="lineNum">     811 </span>                :            :                 }
<span class="lineNum">     812 </span>                :<span class="lineNoCov">          0 :                 mutex_exit(&amp;dp-&gt;dp_lock);</span>
<span class="lineNum">     813 </span>                :            : 
<span class="lineNum">     814 </span>                :            :                 /*
<span class="lineNum">     815 </span>                :            :                  * To avoid filling up a TXG with just frees wait for
<span class="lineNum">     816 </span>                :            :                  * the next TXG to open before freeing more chunks if
<span class="lineNum">     817 </span>                :            :                  * we have reached the threshold of frees
<span class="lineNum">     818 </span>                :            :                  */
<span class="lineNum">     819 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :                 if (dirty_frees_threshold != 0 &amp;&amp;</span>
<span class="lineNum">     820 </span>                :<span class="lineNoCov">          0 :                     long_free_dirty_all_txgs &gt;= dirty_frees_threshold) {</span>
<span class="lineNum">     821 </span>                :<span class="lineNoCov">          0 :                         txg_wait_open(dp, 0);</span>
<span class="lineNum">     822 </span>                :<span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">     823 </span>                :            :                 }
<span class="lineNum">     824 </span>                :            : 
<span class="lineNum">     825 </span>                :<span class="lineNoCov">          0 :                 tx = dmu_tx_create(os);</span>
<span class="lineNum">     826 </span>                :<span class="lineNoCov">          0 :                 dmu_tx_hold_free(tx, dn-&gt;dn_object, chunk_begin, chunk_len);</span>
<span class="lineNum">     827 </span>                :            : 
<span class="lineNum">     828 </span>                :            :                 /*
<span class="lineNum">     829 </span>                :            :                  * Mark this transaction as typically resulting in a net
<span class="lineNum">     830 </span>                :            :                  * reduction in space used.
<span class="lineNum">     831 </span>                :            :                  */
<span class="lineNum">     832 </span>                :<span class="lineNoCov">          0 :                 dmu_tx_mark_netfree(tx);</span>
<span class="lineNum">     833 </span>                :<span class="lineNoCov">          0 :                 err = dmu_tx_assign(tx, TXG_WAIT);</span>
<span class="lineNum">     834 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :                 if (err) {</span>
<span class="lineNum">     835 </span>                :<span class="lineNoCov">          0 :                         dmu_tx_abort(tx);</span>
<span class="lineNum">     836 </span>                :<span class="lineNoCov">          0 :                         return (err);</span>
<span class="lineNum">     837 </span>                :            :                 }
<span class="lineNum">     838 </span>                :            : 
<span class="lineNum">     839 </span>                :<span class="lineNoCov">          0 :                 mutex_enter(&amp;dp-&gt;dp_lock);</span>
<span class="lineNum">     840 </span>                :<span class="lineNoCov">          0 :                 dp-&gt;dp_long_free_dirty_pertxg[dmu_tx_get_txg(tx) &amp; TXG_MASK] +=</span>
<span class="lineNum">     841 </span>                :            :                     chunk_len;
<span class="lineNum">     842 </span>                :<span class="lineNoCov">          0 :                 mutex_exit(&amp;dp-&gt;dp_lock);</span>
<span class="lineNum">     843 </span>                :            :                 DTRACE_PROBE3(free__long__range,
<span class="lineNum">     844 </span>                :            :                     uint64_t, long_free_dirty_all_txgs, uint64_t, chunk_len,
<span class="lineNum">     845 </span>                :            :                     uint64_t, dmu_tx_get_txg(tx));
<span class="lineNum">     846 </span>                :<span class="lineNoCov">          0 :                 dnode_free_range(dn, chunk_begin, chunk_len, tx);</span>
<span class="lineNum">     847 </span>                :<span class="lineNoCov">          0 :                 dmu_tx_commit(tx);</span>
<span class="lineNum">     848 </span>                :            : 
<span class="lineNum">     849 </span>                :<span class="lineNoCov">          0 :                 length -= chunk_len;</span>
<span class="lineNum">     850 </span>                :            :         }
<span class="lineNum">     851 </span>                :            :         return (0);
<span class="lineNum">     852 </span>                :            : }
<a name="853"><span class="lineNum">     853 </span>                :            : </a>
<span class="lineNum">     854 </span>                :            : int
<span class="lineNum">     855 </span>                :<span class="lineNoCov">          0 : dmu_free_long_range(objset_t *os, uint64_t object,</span>
<span class="lineNum">     856 </span>                :            :     uint64_t offset, uint64_t length)
<span class="lineNum">     857 </span>                :            : {
<span class="lineNum">     858 </span>                :            :         dnode_t *dn;
<span class="lineNum">     859 </span>                :            :         int err;
<span class="lineNum">     860 </span>                :            : 
<span class="lineNum">     861 </span>                :<span class="lineNoCov">          0 :         err = dnode_hold(os, object, FTAG, &amp;dn);</span>
<span class="lineNum">     862 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :         if (err != 0)</span>
<span class="lineNum">     863 </span>                :            :                 return (err);
<span class="lineNum">     864 </span>                :<span class="lineNoCov">          0 :         err = dmu_free_long_range_impl(os, dn, offset, length);</span>
<span class="lineNum">     865 </span>                :            : 
<span class="lineNum">     866 </span>                :            :         /*
<span class="lineNum">     867 </span>                :            :          * It is important to zero out the maxblkid when freeing the entire
<span class="lineNum">     868 </span>                :            :          * file, so that (a) subsequent calls to dmu_free_long_range_impl()
<span class="lineNum">     869 </span>                :            :          * will take the fast path, and (b) dnode_reallocate() can verify
<span class="lineNum">     870 </span>                :            :          * that the entire file has been freed.
<span class="lineNum">     871 </span>                :            :          */
<span class="lineNum">     872 </span>[<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>][<span class="branchNoExec" title="Branch 2 was not executed"> # </span><span class="branchNoExec" title="Branch 3 was not executed"> # </span>]:<span class="lineNoCov">          0 :         if (err == 0 &amp;&amp; offset == 0 &amp;&amp; length == DMU_OBJECT_END)</span>
<span class="lineNum">     873 </span>                :<span class="lineNoCov">          0 :                 dn-&gt;dn_maxblkid = 0;</span>
<span class="lineNum">     874 </span>                :            : 
<span class="lineNum">     875 </span>                :<span class="lineNoCov">          0 :         dnode_rele(dn, FTAG);</span>
<span class="lineNum">     876 </span>                :<span class="lineNoCov">          0 :         return (err);</span>
<span class="lineNum">     877 </span>                :            : }
<a name="878"><span class="lineNum">     878 </span>                :            : </a>
<span class="lineNum">     879 </span>                :            : int
<span class="lineNum">     880 </span>                :<span class="lineNoCov">          0 : dmu_free_long_object(objset_t *os, uint64_t object)</span>
<span class="lineNum">     881 </span>                :            : {
<span class="lineNum">     882 </span>                :            :         dmu_tx_t *tx;
<span class="lineNum">     883 </span>                :            :         int err;
<span class="lineNum">     884 </span>                :            : 
<span class="lineNum">     885 </span>                :<span class="lineNoCov">          0 :         err = dmu_free_long_range(os, object, 0, DMU_OBJECT_END);</span>
<span class="lineNum">     886 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :         if (err != 0)</span>
<span class="lineNum">     887 </span>                :            :                 return (err);
<span class="lineNum">     888 </span>                :            : 
<span class="lineNum">     889 </span>                :<span class="lineNoCov">          0 :         tx = dmu_tx_create(os);</span>
<span class="lineNum">     890 </span>                :<span class="lineNoCov">          0 :         dmu_tx_hold_bonus(tx, object);</span>
<span class="lineNum">     891 </span>                :<span class="lineNoCov">          0 :         dmu_tx_hold_free(tx, object, 0, DMU_OBJECT_END);</span>
<span class="lineNum">     892 </span>                :<span class="lineNoCov">          0 :         dmu_tx_mark_netfree(tx);</span>
<span class="lineNum">     893 </span>                :<span class="lineNoCov">          0 :         err = dmu_tx_assign(tx, TXG_WAIT);</span>
<span class="lineNum">     894 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :         if (err == 0) {</span>
<span class="lineNum">     895 </span>                :<span class="lineNoCov">          0 :                 err = dmu_object_free(os, object, tx);</span>
<span class="lineNum">     896 </span>                :<span class="lineNoCov">          0 :                 dmu_tx_commit(tx);</span>
<span class="lineNum">     897 </span>                :            :         } else {
<span class="lineNum">     898 </span>                :<span class="lineNoCov">          0 :                 dmu_tx_abort(tx);</span>
<span class="lineNum">     899 </span>                :            :         }
<span class="lineNum">     900 </span>                :            : 
<span class="lineNum">     901 </span>                :            :         return (err);
<span class="lineNum">     902 </span>                :            : }
<a name="903"><span class="lineNum">     903 </span>                :            : </a>
<span class="lineNum">     904 </span>                :            : int
<span class="lineNum">     905 </span>                :<span class="lineCov">      14605 : dmu_free_range(objset_t *os, uint64_t object, uint64_t offset,</span>
<span class="lineNum">     906 </span>                :            :     uint64_t size, dmu_tx_t *tx)
<span class="lineNum">     907 </span>                :            : {
<span class="lineNum">     908 </span>                :            :         dnode_t *dn;
<span class="lineNum">     909 </span>                :<span class="lineCov">      14605 :         int err = dnode_hold(os, object, FTAG, &amp;dn);</span>
<span class="lineNum">     910 </span>        [<span class="branchCov" title="Branch 0 was taken 14605 times"> + </span><span class="branchNoCov" title="Branch 1 was not taken"> - </span>]:<span class="lineCov">      14605 :         if (err)</span>
<span class="lineNum">     911 </span>                :            :                 return (err);
<span class="lineNum">     912 </span>        [<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 14605 times"> + </span>]:<span class="lineCov">      14605 :         ASSERT(offset &lt; UINT64_MAX);</span>
<span class="lineNum">     913 </span>[<span class="branchCov" title="Branch 0 was taken 2705 times"> + </span><span class="branchCov" title="Branch 1 was taken 11900 times"> + </span>][<span class="branchNoCov" title="Branch 2 was not taken"> - </span><span class="branchCov" title="Branch 3 was taken 2705 times"> + </span>]:<span class="lineCov">      14605 :         ASSERT(size == -1ULL || size &lt;= UINT64_MAX - offset);</span>
<span class="lineNum">     914 </span>                :<span class="lineCov">      14605 :         dnode_free_range(dn, offset, size, tx);</span>
<span class="lineNum">     915 </span>                :<span class="lineCov">      14605 :         dnode_rele(dn, FTAG);</span>
<span class="lineNum">     916 </span>                :<span class="lineCov">      14605 :         return (0);</span>
<span class="lineNum">     917 </span>                :            : }
<a name="918"><span class="lineNum">     918 </span>                :            : </a>
<span class="lineNum">     919 </span>                :            : static int
<span class="lineNum">     920 </span>                :<span class="lineCov">      76945 : dmu_read_impl(dnode_t *dn, uint64_t offset, uint64_t size,</span>
<span class="lineNum">     921 </span>                :            :     void *buf, uint32_t flags)
<span class="lineNum">     922 </span>                :            : {
<span class="lineNum">     923 </span>                :            :         dmu_buf_t **dbp;
<span class="lineNum">     924 </span>                :<span class="lineCov">      76945 :         int numbufs, err = 0;</span>
<span class="lineNum">     925 </span>                :            : 
<span class="lineNum">     926 </span>                :            :         /*
<span class="lineNum">     927 </span>                :            :          * Deal with odd block sizes, where there can't be data past the first
<span class="lineNum">     928 </span>                :            :          * block.  If we ever do the tail block optimization, we will need to
<span class="lineNum">     929 </span>                :            :          * handle that here as well.
<span class="lineNum">     930 </span>                :            :          */
<span class="lineNum">     931 </span>        [<span class="branchCov" title="Branch 0 was taken 44471 times"> + </span><span class="branchCov" title="Branch 1 was taken 32474 times"> + </span>]:<span class="lineCov">      76945 :         if (dn-&gt;dn_maxblkid == 0) {</span>
<span class="lineNum">     932 </span>        [<span class="branchCov" title="Branch 0 was taken 34340 times"> + </span><span class="branchCov" title="Branch 1 was taken 10131 times"> + </span>]:<span class="lineCov">      44471 :                 uint64_t newsz = offset &gt; dn-&gt;dn_datablksz ? 0 :</span>
<span class="lineNum">     933 </span>                :<span class="lineCov">      34340 :                     MIN(size, dn-&gt;dn_datablksz - offset);</span>
<span class="lineNum">     934 </span>                :<span class="lineCov">      88942 :                 bzero((char *)buf + newsz, size - newsz);</span>
<span class="lineNum">     935 </span>                :<span class="lineCov">      76945 :                 size = newsz;</span>
<span class="lineNum">     936 </span>                :            :         }
<span class="lineNum">     937 </span>                :            : 
<span class="lineNum">     938 </span>        [<span class="branchCov" title="Branch 0 was taken 66593 times"> + </span><span class="branchCov" title="Branch 1 was taken 76950 times"> + </span>]:<span class="lineCov">     143543 :         while (size &gt; 0) {</span>
<span class="lineNum">     939 </span>                :<span class="lineCov">      66593 :                 uint64_t mylen = MIN(size, DMU_MAX_ACCESS / 2);</span>
<span class="lineNum">     940 </span>                :            :                 int i;
<span class="lineNum">     941 </span>                :            : 
<span class="lineNum">     942 </span>                :            :                 /*
<span class="lineNum">     943 </span>                :            :                  * NB: we could do this block-at-a-time, but it's nice
<span class="lineNum">     944 </span>                :            :                  * to be reading in parallel.
<span class="lineNum">     945 </span>                :            :                  */
<span class="lineNum">     946 </span>                :<span class="lineCov">      66593 :                 err = dmu_buf_hold_array_by_dnode(dn, offset, mylen,</span>
<span class="lineNum">     947 </span>                :            :                     TRUE, FTAG, &amp;numbufs, &amp;dbp, flags);
<span class="lineNum">     948 </span>           [<span class="branchCov" title="Branch 0 was taken 67192 times"> + </span>]:<span class="lineCov">      66597 :                 if (err)</span>
<span class="lineNum">     949 </span>                :            :                         break;
<span class="lineNum">     950 </span>                :            : 
<span class="lineNum">     951 </span>        [<span class="branchCov" title="Branch 0 was taken 102421 times"> + </span><span class="branchCov" title="Branch 1 was taken 66592 times"> + </span>]:<span class="lineCov">     169013 :                 for (i = 0; i &lt; numbufs; i++) {</span>
<span class="lineNum">     952 </span>                :            :                         uint64_t tocpy;
<span class="lineNum">     953 </span>                :            :                         int64_t bufoff;
<span class="lineNum">     954 </span>                :<span class="lineCov">     102421 :                         dmu_buf_t *db = dbp[i];</span>
<span class="lineNum">     955 </span>                :            : 
<span class="lineNum">     956 </span>        [<span class="branchCov" title="Branch 0 was taken 600 times"> + </span><span class="branchCov" title="Branch 1 was taken 101821 times"> + </span>]:<span class="lineCov">     102421 :                         ASSERT(size &gt; 0);</span>
<span class="lineNum">     957 </span>                :            : 
<span class="lineNum">     958 </span>                :<span class="lineCov">     101821 :                         bufoff = offset - db-&gt;db_offset;</span>
<span class="lineNum">     959 </span>                :<span class="lineCov">     101821 :                         tocpy = MIN(db-&gt;db_size - bufoff, size);</span>
<span class="lineNum">     960 </span>                :            : 
<span class="lineNum">     961 </span>                :<span class="lineCov">     203642 :                         (void) memcpy(buf, (char *)db-&gt;db_data + bufoff, tocpy);</span>
<span class="lineNum">     962 </span>                :            : 
<span class="lineNum">     963 </span>                :<span class="lineCov">     101821 :                         offset += tocpy;</span>
<span class="lineNum">     964 </span>                :<span class="lineCov">     101821 :                         size -= tocpy;</span>
<span class="lineNum">     965 </span>                :<span class="lineCov">     101821 :                         buf = (char *)buf + tocpy;</span>
<span class="lineNum">     966 </span>                :            :                 }
<span class="lineNum">     967 </span>                :<span class="lineCov">      66592 :                 dmu_buf_rele_array(dbp, numbufs, FTAG);</span>
<span class="lineNum">     968 </span>                :            :         }
<span class="lineNum">     969 </span>                :<span class="lineCov">      76355 :         return (err);</span>
<span class="lineNum">     970 </span>                :            : }
<a name="971"><span class="lineNum">     971 </span>                :            : </a>
<span class="lineNum">     972 </span>                :            : int
<span class="lineNum">     973 </span>                :<span class="lineCov">      76951 : dmu_read(objset_t *os, uint64_t object, uint64_t offset, uint64_t size,</span>
<span class="lineNum">     974 </span>                :            :     void *buf, uint32_t flags)
<span class="lineNum">     975 </span>                :            : {
<span class="lineNum">     976 </span>                :            :         dnode_t *dn;
<span class="lineNum">     977 </span>                :            :         int err;
<span class="lineNum">     978 </span>                :            : 
<span class="lineNum">     979 </span>                :<span class="lineCov">      76951 :         err = dnode_hold(os, object, FTAG, &amp;dn);</span>
<span class="lineNum">     980 </span>           [<span class="branchCov" title="Branch 0 was taken 76952 times"> + </span>]:<span class="lineCov">      76951 :         if (err != 0)</span>
<span class="lineNum">     981 </span>                :            :                 return (err);
<span class="lineNum">     982 </span>                :            : 
<span class="lineNum">     983 </span>                :<span class="lineCov">      76952 :         err = dmu_read_impl(dn, offset, size, buf, flags);</span>
<span class="lineNum">     984 </span>                :<span class="lineCov">      76949 :         dnode_rele(dn, FTAG);</span>
<span class="lineNum">     985 </span>                :<span class="lineCov">      76951 :         return (err);</span>
<span class="lineNum">     986 </span>                :            : }
<a name="987"><span class="lineNum">     987 </span>                :            : </a>
<span class="lineNum">     988 </span>                :            : int
<span class="lineNum">     989 </span>                :<span class="lineNoCov">          0 : dmu_read_by_dnode(dnode_t *dn, uint64_t offset, uint64_t size, void *buf,</span>
<span class="lineNum">     990 </span>                :            :     uint32_t flags)
<span class="lineNum">     991 </span>                :            : {
<span class="lineNum">     992 </span>                :<span class="lineNoCov">          0 :         return (dmu_read_impl(dn, offset, size, buf, flags));</span>
<span class="lineNum">     993 </span>                :            : }
<a name="994"><span class="lineNum">     994 </span>                :            : </a>
<span class="lineNum">     995 </span>                :            : static void
<span class="lineNum">     996 </span>                :<span class="lineCov">     145220 : dmu_write_impl(dmu_buf_t **dbp, int numbufs, uint64_t offset, uint64_t size,</span>
<span class="lineNum">     997 </span>                :            :     const void *buf, dmu_tx_t *tx)
<span class="lineNum">     998 </span>                :            : {
<span class="lineNum">     999 </span>                :            :         int i;
<span class="lineNum">    1000 </span>                :            : 
<span class="lineNum">    1001 </span>        [<span class="branchCov" title="Branch 0 was taken 167493 times"> + </span><span class="branchCov" title="Branch 1 was taken 145222 times"> + </span>]:<span class="lineCov">     312715 :         for (i = 0; i &lt; numbufs; i++) {</span>
<span class="lineNum">    1002 </span>                :            :                 uint64_t tocpy;
<span class="lineNum">    1003 </span>                :            :                 int64_t bufoff;
<span class="lineNum">    1004 </span>                :<span class="lineCov">     167493 :                 dmu_buf_t *db = dbp[i];</span>
<span class="lineNum">    1005 </span>                :            : 
<span class="lineNum">    1006 </span>        [<span class="branchCov" title="Branch 0 was taken 2 times"> + </span><span class="branchCov" title="Branch 1 was taken 167491 times"> + </span>]:<span class="lineCov">     167493 :                 ASSERT(size &gt; 0);</span>
<span class="lineNum">    1007 </span>                :            : 
<span class="lineNum">    1008 </span>                :<span class="lineCov">     167491 :                 bufoff = offset - db-&gt;db_offset;</span>
<span class="lineNum">    1009 </span>                :<span class="lineCov">     167491 :                 tocpy = MIN(db-&gt;db_size - bufoff, size);</span>
<span class="lineNum">    1010 </span>                :            : 
<span class="lineNum">    1011 </span>[<span class="branchCov" title="Branch 0 was taken 22274 times"> + </span><span class="branchCov" title="Branch 1 was taken 145217 times"> + </span>][<span class="branchCov" title="Branch 2 was taken 21236 times"> + </span><span class="branchCov" title="Branch 3 was taken 1038 times"> + </span>]:<span class="lineCov">     167491 :                 ASSERT(i == 0 || i == numbufs-1 || tocpy == db-&gt;db_size);</span>
<span class="lineNum">         </span>        [<span class="branchNoCov" title="Branch 4 was not taken"> - </span><span class="branchCov" title="Branch 5 was taken 21236 times"> + </span>]
<span class="lineNum">    1012 </span>                :            : 
<span class="lineNum">    1013 </span>        [<span class="branchCov" title="Branch 0 was taken 30178 times"> + </span><span class="branchCov" title="Branch 1 was taken 137313 times"> + </span>]:<span class="lineCov">     167491 :                 if (tocpy == db-&gt;db_size)</span>
<span class="lineNum">    1014 </span>                :<span class="lineCov">      30178 :                         dmu_buf_will_fill(db, tx);</span>
<span class="lineNum">    1015 </span>                :            :                 else
<span class="lineNum">    1016 </span>                :<span class="lineCov">     137313 :                         dmu_buf_will_dirty(db, tx);</span>
<span class="lineNum">    1017 </span>                :            : 
<span class="lineNum">    1018 </span>                :<span class="lineCov">     334990 :                 (void) memcpy((char *)db-&gt;db_data + bufoff, buf, tocpy);</span>
<span class="lineNum">    1019 </span>                :            : 
<span class="lineNum">    1020 </span>        [<span class="branchCov" title="Branch 0 was taken 30179 times"> + </span><span class="branchCov" title="Branch 1 was taken 137316 times"> + </span>]:<span class="lineCov">     167495 :                 if (tocpy == db-&gt;db_size)</span>
<span class="lineNum">    1021 </span>                :<span class="lineCov">      30179 :                         dmu_buf_fill_done(db, tx);</span>
<span class="lineNum">    1022 </span>                :            : 
<span class="lineNum">    1023 </span>                :<span class="lineCov">     167495 :                 offset += tocpy;</span>
<span class="lineNum">    1024 </span>                :<span class="lineCov">     167495 :                 size -= tocpy;</span>
<span class="lineNum">    1025 </span>                :<span class="lineCov">     167495 :                 buf = (char *)buf + tocpy;</span>
<span class="lineNum">    1026 </span>                :            :         }
<span class="lineNum">    1027 </span>                :<span class="lineCov">     145222 : }</span>
<a name="1028"><span class="lineNum">    1028 </span>                :            : </a>
<span class="lineNum">    1029 </span>                :            : void
<span class="lineNum">    1030 </span>                :<span class="lineCov">     145218 : dmu_write(objset_t *os, uint64_t object, uint64_t offset, uint64_t size,</span>
<span class="lineNum">    1031 </span>                :            :     const void *buf, dmu_tx_t *tx)
<span class="lineNum">    1032 </span>                :            : {
<span class="lineNum">    1033 </span>                :            :         dmu_buf_t **dbp;
<span class="lineNum">    1034 </span>                :            :         int numbufs;
<span class="lineNum">    1035 </span>                :            : 
<span class="lineNum">    1036 </span>        [<span class="branchCov" title="Branch 0 was taken 145218 times"> + </span><span class="branchNoCov" title="Branch 1 was not taken"> - </span>]:<span class="lineCov">     145218 :         if (size == 0)</span>
<span class="lineNum">    1037 </span>                :<span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    1038 </span>                :            : 
<span class="lineNum">    1039 </span>        [<span class="branchNoCov" title="Branch 1 was not taken"> - </span><span class="branchCov" title="Branch 2 was taken 145219 times"> + </span>]:<span class="lineCov">     145218 :         VERIFY0(dmu_buf_hold_array(os, object, offset, size,</span>
<span class="lineNum">    1040 </span>                :            :             FALSE, FTAG, &amp;numbufs, &amp;dbp));
<span class="lineNum">    1041 </span>                :<span class="lineCov">     145219 :         dmu_write_impl(dbp, numbufs, offset, size, buf, tx);</span>
<span class="lineNum">    1042 </span>                :<span class="lineCov">     145222 :         dmu_buf_rele_array(dbp, numbufs, FTAG);</span>
<span class="lineNum">    1043 </span>                :            : }
<a name="1044"><span class="lineNum">    1044 </span>                :            : </a>
<span class="lineNum">    1045 </span>                :            : void
<span class="lineNum">    1046 </span>                :<span class="lineNoCov">          0 : dmu_write_by_dnode(dnode_t *dn, uint64_t offset, uint64_t size,</span>
<span class="lineNum">    1047 </span>                :            :     const void *buf, dmu_tx_t *tx)
<span class="lineNum">    1048 </span>                :            : {
<span class="lineNum">    1049 </span>                :            :         dmu_buf_t **dbp;
<span class="lineNum">    1050 </span>                :            :         int numbufs;
<span class="lineNum">    1051 </span>                :            : 
<span class="lineNum">    1052 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :         if (size == 0)</span>
<span class="lineNum">    1053 </span>                :<span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    1054 </span>                :            : 
<span class="lineNum">    1055 </span>        [<span class="branchNoExec" title="Branch 1 was not executed"> # </span><span class="branchNoExec" title="Branch 2 was not executed"> # </span>]:<span class="lineNoCov">          0 :         VERIFY0(dmu_buf_hold_array_by_dnode(dn, offset, size,</span>
<span class="lineNum">    1056 </span>                :            :             FALSE, FTAG, &amp;numbufs, &amp;dbp, DMU_READ_PREFETCH));
<span class="lineNum">    1057 </span>                :<span class="lineNoCov">          0 :         dmu_write_impl(dbp, numbufs, offset, size, buf, tx);</span>
<span class="lineNum">    1058 </span>                :<span class="lineNoCov">          0 :         dmu_buf_rele_array(dbp, numbufs, FTAG);</span>
<span class="lineNum">    1059 </span>                :            : }
<a name="1060"><span class="lineNum">    1060 </span>                :            : </a>
<span class="lineNum">    1061 </span>                :            : void
<span class="lineNum">    1062 </span>                :<span class="lineNoCov">          0 : dmu_prealloc(objset_t *os, uint64_t object, uint64_t offset, uint64_t size,</span>
<span class="lineNum">    1063 </span>                :            :     dmu_tx_t *tx)
<span class="lineNum">    1064 </span>                :            : {
<span class="lineNum">    1065 </span>                :            :         dmu_buf_t **dbp;
<span class="lineNum">    1066 </span>                :            :         int numbufs, i;
<span class="lineNum">    1067 </span>                :            : 
<span class="lineNum">    1068 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :         if (size == 0)</span>
<span class="lineNum">    1069 </span>                :<span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    1070 </span>                :            : 
<span class="lineNum">    1071 </span>        [<span class="branchNoExec" title="Branch 1 was not executed"> # </span><span class="branchNoExec" title="Branch 2 was not executed"> # </span>]:<span class="lineNoCov">          0 :         VERIFY(0 == dmu_buf_hold_array(os, object, offset, size,</span>
<span class="lineNum">    1072 </span>                :            :             FALSE, FTAG, &amp;numbufs, &amp;dbp));
<span class="lineNum">    1073 </span>                :            : 
<span class="lineNum">    1074 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :         for (i = 0; i &lt; numbufs; i++) {</span>
<span class="lineNum">    1075 </span>                :<span class="lineNoCov">          0 :                 dmu_buf_t *db = dbp[i];</span>
<span class="lineNum">    1076 </span>                :            : 
<span class="lineNum">    1077 </span>                :<span class="lineNoCov">          0 :                 dmu_buf_will_not_fill(db, tx);</span>
<span class="lineNum">    1078 </span>                :            :         }
<span class="lineNum">    1079 </span>                :<span class="lineNoCov">          0 :         dmu_buf_rele_array(dbp, numbufs, FTAG);</span>
<span class="lineNum">    1080 </span>                :            : }
<a name="1081"><span class="lineNum">    1081 </span>                :            : </a>
<span class="lineNum">    1082 </span>                :            : void
<span class="lineNum">    1083 </span>                :<span class="lineNoCov">          0 : dmu_write_embedded(objset_t *os, uint64_t object, uint64_t offset,</span>
<span class="lineNum">    1084 </span>                :            :     void *data, uint8_t etype, uint8_t comp, int uncompressed_size,
<span class="lineNum">    1085 </span>                :            :     int compressed_size, int byteorder, dmu_tx_t *tx)
<span class="lineNum">    1086 </span>                :            : {
<span class="lineNum">    1087 </span>                :            :         dmu_buf_t *db;
<span class="lineNum">    1088 </span>                :            : 
<span class="lineNum">    1089 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :         ASSERT3U(etype, &lt;, NUM_BP_EMBEDDED_TYPES);</span>
<span class="lineNum">    1090 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :         ASSERT3U(comp, &lt;, ZIO_COMPRESS_FUNCTIONS);</span>
<span class="lineNum">    1091 </span>        [<span class="branchNoExec" title="Branch 1 was not executed"> # </span><span class="branchNoExec" title="Branch 2 was not executed"> # </span>]:<span class="lineNoCov">          0 :         VERIFY0(dmu_buf_hold_noread(os, object, offset,</span>
<span class="lineNum">    1092 </span>                :            :             FTAG, &amp;db));
<span class="lineNum">    1093 </span>                :            : 
<span class="lineNum">    1094 </span>                :<span class="lineNoCov">          0 :         dmu_buf_write_embedded(db,</span>
<span class="lineNum">    1095 </span>                :            :             data, (bp_embedded_type_t)etype, (enum zio_compress)comp,
<span class="lineNum">    1096 </span>                :            :             uncompressed_size, compressed_size, byteorder, tx);
<span class="lineNum">    1097 </span>                :            : 
<span class="lineNum">    1098 </span>                :<span class="lineNoCov">          0 :         dmu_buf_rele(db, FTAG);</span>
<span class="lineNum">    1099 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1100 </span>                :            : 
<span class="lineNum">    1101 </span>                :            : /*
<span class="lineNum">    1102 </span>                :            :  * DMU support for xuio
<span class="lineNum">    1103 </span>                :            :  */
<span class="lineNum">    1104 </span>                :            : kstat_t *xuio_ksp = NULL;
<span class="lineNum">    1105 </span>                :            : 
<span class="lineNum">    1106 </span>                :            : typedef struct xuio_stats {
<span class="lineNum">    1107 </span>                :            :         /* loaned yet not returned arc_buf */
<span class="lineNum">    1108 </span>                :            :         kstat_named_t xuiostat_onloan_rbuf;
<span class="lineNum">    1109 </span>                :            :         kstat_named_t xuiostat_onloan_wbuf;
<span class="lineNum">    1110 </span>                :            :         /* whether a copy is made when loaning out a read buffer */
<span class="lineNum">    1111 </span>                :            :         kstat_named_t xuiostat_rbuf_copied;
<span class="lineNum">    1112 </span>                :            :         kstat_named_t xuiostat_rbuf_nocopy;
<span class="lineNum">    1113 </span>                :            :         /* whether a copy is made when assigning a write buffer */
<span class="lineNum">    1114 </span>                :            :         kstat_named_t xuiostat_wbuf_copied;
<span class="lineNum">    1115 </span>                :            :         kstat_named_t xuiostat_wbuf_nocopy;
<span class="lineNum">    1116 </span>                :            : } xuio_stats_t;
<span class="lineNum">    1117 </span>                :            : 
<span class="lineNum">    1118 </span>                :            : static xuio_stats_t xuio_stats = {
<span class="lineNum">    1119 </span>                :            :         { &quot;onloan_read_buf&quot;,  KSTAT_DATA_UINT64 },
<span class="lineNum">    1120 </span>                :            :         { &quot;onloan_write_buf&quot;, KSTAT_DATA_UINT64 },
<span class="lineNum">    1121 </span>                :            :         { &quot;read_buf_copied&quot;,  KSTAT_DATA_UINT64 },
<span class="lineNum">    1122 </span>                :            :         { &quot;read_buf_nocopy&quot;,  KSTAT_DATA_UINT64 },
<span class="lineNum">    1123 </span>                :            :         { &quot;write_buf_copied&quot;, KSTAT_DATA_UINT64 },
<span class="lineNum">    1124 </span>                :            :         { &quot;write_buf_nocopy&quot;, KSTAT_DATA_UINT64 }
<span class="lineNum">    1125 </span>                :            : };
<span class="lineNum">    1126 </span>                :            : 
<span class="lineNum">    1127 </span>                :            : #define XUIOSTAT_INCR(stat, val)        \
<span class="lineNum">    1128 </span>                :            :         atomic_add_64(&amp;xuio_stats.stat.value.ui64, (val))
<span class="lineNum">    1129 </span>                :            : #define XUIOSTAT_BUMP(stat)     XUIOSTAT_INCR(stat, 1)
<span class="lineNum">    1130 </span>                :            : 
<span class="lineNum">    1131 </span>                :            : #ifdef HAVE_UIO_ZEROCOPY
<span class="lineNum">    1132 </span>                :            : int
<span class="lineNum">    1133 </span>                :            : dmu_xuio_init(xuio_t *xuio, int nblk)
<span class="lineNum">    1134 </span>                :            : {
<span class="lineNum">    1135 </span>                :            :         dmu_xuio_t *priv;
<span class="lineNum">    1136 </span>                :            :         uio_t *uio = &amp;xuio-&gt;xu_uio;
<span class="lineNum">    1137 </span>                :            : 
<span class="lineNum">    1138 </span>                :            :         uio-&gt;uio_iovcnt = nblk;
<span class="lineNum">    1139 </span>                :            :         uio-&gt;uio_iov = kmem_zalloc(nblk * sizeof (iovec_t), KM_SLEEP);
<span class="lineNum">    1140 </span>                :            : 
<span class="lineNum">    1141 </span>                :            :         priv = kmem_zalloc(sizeof (dmu_xuio_t), KM_SLEEP);
<span class="lineNum">    1142 </span>                :            :         priv-&gt;cnt = nblk;
<span class="lineNum">    1143 </span>                :            :         priv-&gt;bufs = kmem_zalloc(nblk * sizeof (arc_buf_t *), KM_SLEEP);
<span class="lineNum">    1144 </span>                :            :         priv-&gt;iovp = (iovec_t *)uio-&gt;uio_iov;
<span class="lineNum">    1145 </span>                :            :         XUIO_XUZC_PRIV(xuio) = priv;
<span class="lineNum">    1146 </span>                :            : 
<span class="lineNum">    1147 </span>                :            :         if (XUIO_XUZC_RW(xuio) == UIO_READ)
<span class="lineNum">    1148 </span>                :            :                 XUIOSTAT_INCR(xuiostat_onloan_rbuf, nblk);
<span class="lineNum">    1149 </span>                :            :         else
<span class="lineNum">    1150 </span>                :            :                 XUIOSTAT_INCR(xuiostat_onloan_wbuf, nblk);
<span class="lineNum">    1151 </span>                :            : 
<span class="lineNum">    1152 </span>                :            :         return (0);
<span class="lineNum">    1153 </span>                :            : }
<span class="lineNum">    1154 </span>                :            : 
<span class="lineNum">    1155 </span>                :            : void
<span class="lineNum">    1156 </span>                :            : dmu_xuio_fini(xuio_t *xuio)
<span class="lineNum">    1157 </span>                :            : {
<span class="lineNum">    1158 </span>                :            :         dmu_xuio_t *priv = XUIO_XUZC_PRIV(xuio);
<span class="lineNum">    1159 </span>                :            :         int nblk = priv-&gt;cnt;
<span class="lineNum">    1160 </span>                :            : 
<span class="lineNum">    1161 </span>                :            :         kmem_free(priv-&gt;iovp, nblk * sizeof (iovec_t));
<span class="lineNum">    1162 </span>                :            :         kmem_free(priv-&gt;bufs, nblk * sizeof (arc_buf_t *));
<span class="lineNum">    1163 </span>                :            :         kmem_free(priv, sizeof (dmu_xuio_t));
<span class="lineNum">    1164 </span>                :            : 
<span class="lineNum">    1165 </span>                :            :         if (XUIO_XUZC_RW(xuio) == UIO_READ)
<span class="lineNum">    1166 </span>                :            :                 XUIOSTAT_INCR(xuiostat_onloan_rbuf, -nblk);
<span class="lineNum">    1167 </span>                :            :         else
<span class="lineNum">    1168 </span>                :            :                 XUIOSTAT_INCR(xuiostat_onloan_wbuf, -nblk);
<span class="lineNum">    1169 </span>                :            : }
<span class="lineNum">    1170 </span>                :            : 
<span class="lineNum">    1171 </span>                :            : /*
<span class="lineNum">    1172 </span>                :            :  * Initialize iov[priv-&gt;next] and priv-&gt;bufs[priv-&gt;next] with { off, n, abuf }
<span class="lineNum">    1173 </span>                :            :  * and increase priv-&gt;next by 1.
<span class="lineNum">    1174 </span>                :            :  */
<span class="lineNum">    1175 </span>                :            : int
<span class="lineNum">    1176 </span>                :            : dmu_xuio_add(xuio_t *xuio, arc_buf_t *abuf, offset_t off, size_t n)
<span class="lineNum">    1177 </span>                :            : {
<span class="lineNum">    1178 </span>                :            :         struct iovec *iov;
<span class="lineNum">    1179 </span>                :            :         uio_t *uio = &amp;xuio-&gt;xu_uio;
<span class="lineNum">    1180 </span>                :            :         dmu_xuio_t *priv = XUIO_XUZC_PRIV(xuio);
<span class="lineNum">    1181 </span>                :            :         int i = priv-&gt;next++;
<span class="lineNum">    1182 </span>                :            : 
<span class="lineNum">    1183 </span>                :            :         ASSERT(i &lt; priv-&gt;cnt);
<span class="lineNum">    1184 </span>                :            :         ASSERT(off + n &lt;= arc_buf_lsize(abuf));
<span class="lineNum">    1185 </span>                :            :         iov = (iovec_t *)uio-&gt;uio_iov + i;
<span class="lineNum">    1186 </span>                :            :         iov-&gt;iov_base = (char *)abuf-&gt;b_data + off;
<span class="lineNum">    1187 </span>                :            :         iov-&gt;iov_len = n;
<span class="lineNum">    1188 </span>                :            :         priv-&gt;bufs[i] = abuf;
<span class="lineNum">    1189 </span>                :            :         return (0);
<span class="lineNum">    1190 </span>                :            : }
<span class="lineNum">    1191 </span>                :            : 
<span class="lineNum">    1192 </span>                :            : int
<span class="lineNum">    1193 </span>                :            : dmu_xuio_cnt(xuio_t *xuio)
<span class="lineNum">    1194 </span>                :            : {
<span class="lineNum">    1195 </span>                :            :         dmu_xuio_t *priv = XUIO_XUZC_PRIV(xuio);
<span class="lineNum">    1196 </span>                :            :         return (priv-&gt;cnt);
<span class="lineNum">    1197 </span>                :            : }
<span class="lineNum">    1198 </span>                :            : 
<span class="lineNum">    1199 </span>                :            : arc_buf_t *
<span class="lineNum">    1200 </span>                :            : dmu_xuio_arcbuf(xuio_t *xuio, int i)
<span class="lineNum">    1201 </span>                :            : {
<span class="lineNum">    1202 </span>                :            :         dmu_xuio_t *priv = XUIO_XUZC_PRIV(xuio);
<span class="lineNum">    1203 </span>                :            : 
<span class="lineNum">    1204 </span>                :            :         ASSERT(i &lt; priv-&gt;cnt);
<span class="lineNum">    1205 </span>                :            :         return (priv-&gt;bufs[i]);
<span class="lineNum">    1206 </span>                :            : }
<span class="lineNum">    1207 </span>                :            : 
<span class="lineNum">    1208 </span>                :            : void
<span class="lineNum">    1209 </span>                :            : dmu_xuio_clear(xuio_t *xuio, int i)
<span class="lineNum">    1210 </span>                :            : {
<span class="lineNum">    1211 </span>                :            :         dmu_xuio_t *priv = XUIO_XUZC_PRIV(xuio);
<span class="lineNum">    1212 </span>                :            : 
<span class="lineNum">    1213 </span>                :            :         ASSERT(i &lt; priv-&gt;cnt);
<span class="lineNum">    1214 </span>                :            :         priv-&gt;bufs[i] = NULL;
<span class="lineNum">    1215 </span>                :            : }
<span class="lineNum">    1216 </span>                :            : #endif /* HAVE_UIO_ZEROCOPY */
<a name="1217"><span class="lineNum">    1217 </span>                :            : </a>
<span class="lineNum">    1218 </span>                :            : static void
<span class="lineNum">    1219 </span>                :<span class="lineCov">       1234 : xuio_stat_init(void)</span>
<span class="lineNum">    1220 </span>                :            : {
<span class="lineNum">    1221 </span>                :<span class="lineCov">       1234 :         xuio_ksp = kstat_create(&quot;zfs&quot;, 0, &quot;xuio_stats&quot;, &quot;misc&quot;,</span>
<span class="lineNum">    1222 </span>                :            :             KSTAT_TYPE_NAMED, sizeof (xuio_stats) / sizeof (kstat_named_t),
<span class="lineNum">    1223 </span>                :            :             KSTAT_FLAG_VIRTUAL);
<span class="lineNum">    1224 </span>        [<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 1234 times"> + </span>]:<span class="lineCov">       1234 :         if (xuio_ksp != NULL) {</span>
<span class="lineNum">    1225 </span>                :<span class="lineNoCov">          0 :                 xuio_ksp-&gt;ks_data = &amp;xuio_stats;</span>
<span class="lineNum">    1226 </span>                :<span class="lineNoCov">          0 :                 kstat_install(xuio_ksp);</span>
<span class="lineNum">    1227 </span>                :            :         }
<span class="lineNum">    1228 </span>                :<span class="lineCov">       1234 : }</span>
<a name="1229"><span class="lineNum">    1229 </span>                :            : </a>
<span class="lineNum">    1230 </span>                :            : static void
<span class="lineNum">    1231 </span>                :<span class="lineCov">        785 : xuio_stat_fini(void)</span>
<span class="lineNum">    1232 </span>                :            : {
<span class="lineNum">    1233 </span>        [<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 785 times"> + </span>]:<span class="lineCov">        785 :         if (xuio_ksp != NULL) {</span>
<span class="lineNum">    1234 </span>                :<span class="lineNoCov">          0 :                 kstat_delete(xuio_ksp);</span>
<span class="lineNum">    1235 </span>                :<span class="lineNoCov">          0 :                 xuio_ksp = NULL;</span>
<span class="lineNum">    1236 </span>                :            :         }
<span class="lineNum">    1237 </span>                :<span class="lineCov">        785 : }</span>
<a name="1238"><span class="lineNum">    1238 </span>                :            : </a>
<span class="lineNum">    1239 </span>                :            : void
<span class="lineNum">    1240 </span>                :<span class="lineCov">        686 : xuio_stat_wbuf_copied(void)</span>
<span class="lineNum">    1241 </span>                :            : {
<span class="lineNum">    1242 </span>                :<span class="lineCov">        686 :         XUIOSTAT_BUMP(xuiostat_wbuf_copied);</span>
<span class="lineNum">    1243 </span>                :<span class="lineCov">        686 : }</span>
<a name="1244"><span class="lineNum">    1244 </span>                :            : </a>
<span class="lineNum">    1245 </span>                :            : void
<span class="lineNum">    1246 </span>                :<span class="lineCov">       3972 : xuio_stat_wbuf_nocopy(void)</span>
<span class="lineNum">    1247 </span>                :            : {
<span class="lineNum">    1248 </span>                :<span class="lineCov">       3972 :         XUIOSTAT_BUMP(xuiostat_wbuf_nocopy);</span>
<span class="lineNum">    1249 </span>                :<span class="lineCov">       3972 : }</span>
<span class="lineNum">    1250 </span>                :            : 
<span class="lineNum">    1251 </span>                :            : #ifdef _KERNEL
<span class="lineNum">    1252 </span>                :            : int
<span class="lineNum">    1253 </span>                :            : dmu_read_uio_dnode(dnode_t *dn, uio_t *uio, uint64_t size)
<span class="lineNum">    1254 </span>                :            : {
<span class="lineNum">    1255 </span>                :            :         dmu_buf_t **dbp;
<span class="lineNum">    1256 </span>                :            :         int numbufs, i, err;
<span class="lineNum">    1257 </span>                :            : #ifdef HAVE_UIO_ZEROCOPY
<span class="lineNum">    1258 </span>                :            :         xuio_t *xuio = NULL;
<span class="lineNum">    1259 </span>                :            : #endif
<span class="lineNum">    1260 </span>                :            : 
<span class="lineNum">    1261 </span>                :            :         /*
<span class="lineNum">    1262 </span>                :            :          * NB: we could do this block-at-a-time, but it's nice
<span class="lineNum">    1263 </span>                :            :          * to be reading in parallel.
<span class="lineNum">    1264 </span>                :            :          */
<span class="lineNum">    1265 </span>                :            :         err = dmu_buf_hold_array_by_dnode(dn, uio-&gt;uio_loffset, size,
<span class="lineNum">    1266 </span>                :            :             TRUE, FTAG, &amp;numbufs, &amp;dbp, 0);
<span class="lineNum">    1267 </span>                :            :         if (err)
<span class="lineNum">    1268 </span>                :            :                 return (err);
<span class="lineNum">    1269 </span>                :            : 
<span class="lineNum">    1270 </span>                :            :         for (i = 0; i &lt; numbufs; i++) {
<span class="lineNum">    1271 </span>                :            :                 uint64_t tocpy;
<span class="lineNum">    1272 </span>                :            :                 int64_t bufoff;
<span class="lineNum">    1273 </span>                :            :                 dmu_buf_t *db = dbp[i];
<span class="lineNum">    1274 </span>                :            : 
<span class="lineNum">    1275 </span>                :            :                 ASSERT(size &gt; 0);
<span class="lineNum">    1276 </span>                :            : 
<span class="lineNum">    1277 </span>                :            :                 bufoff = uio-&gt;uio_loffset - db-&gt;db_offset;
<span class="lineNum">    1278 </span>                :            :                 tocpy = MIN(db-&gt;db_size - bufoff, size);
<span class="lineNum">    1279 </span>                :            : 
<span class="lineNum">    1280 </span>                :            : #ifdef HAVE_UIO_ZEROCOPY
<span class="lineNum">    1281 </span>                :            :                 if (xuio) {
<span class="lineNum">    1282 </span>                :            :                         dmu_buf_impl_t *dbi = (dmu_buf_impl_t *)db;
<span class="lineNum">    1283 </span>                :            :                         arc_buf_t *dbuf_abuf = dbi-&gt;db_buf;
<span class="lineNum">    1284 </span>                :            :                         arc_buf_t *abuf = dbuf_loan_arcbuf(dbi);
<span class="lineNum">    1285 </span>                :            :                         err = dmu_xuio_add(xuio, abuf, bufoff, tocpy);
<span class="lineNum">    1286 </span>                :            :                         if (!err) {
<span class="lineNum">    1287 </span>                :            :                                 uio-&gt;uio_resid -= tocpy;
<span class="lineNum">    1288 </span>                :            :                                 uio-&gt;uio_loffset += tocpy;
<span class="lineNum">    1289 </span>                :            :                         }
<span class="lineNum">    1290 </span>                :            : 
<span class="lineNum">    1291 </span>                :            :                         if (abuf == dbuf_abuf)
<span class="lineNum">    1292 </span>                :            :                                 XUIOSTAT_BUMP(xuiostat_rbuf_nocopy);
<span class="lineNum">    1293 </span>                :            :                         else
<span class="lineNum">    1294 </span>                :            :                                 XUIOSTAT_BUMP(xuiostat_rbuf_copied);
<span class="lineNum">    1295 </span>                :            :                 } else
<span class="lineNum">    1296 </span>                :            : #endif
<span class="lineNum">    1297 </span>                :            :                         err = uiomove((char *)db-&gt;db_data + bufoff, tocpy,
<span class="lineNum">    1298 </span>                :            :                             UIO_READ, uio);
<span class="lineNum">    1299 </span>                :            :                 if (err)
<span class="lineNum">    1300 </span>                :            :                         break;
<span class="lineNum">    1301 </span>                :            : 
<span class="lineNum">    1302 </span>                :            :                 size -= tocpy;
<span class="lineNum">    1303 </span>                :            :         }
<span class="lineNum">    1304 </span>                :            :         dmu_buf_rele_array(dbp, numbufs, FTAG);
<span class="lineNum">    1305 </span>                :            : 
<span class="lineNum">    1306 </span>                :            :         return (err);
<span class="lineNum">    1307 </span>                :            : }
<span class="lineNum">    1308 </span>                :            : 
<span class="lineNum">    1309 </span>                :            : /*
<span class="lineNum">    1310 </span>                :            :  * Read 'size' bytes into the uio buffer.
<span class="lineNum">    1311 </span>                :            :  * From object zdb-&gt;db_object.
<span class="lineNum">    1312 </span>                :            :  * Starting at offset uio-&gt;uio_loffset.
<span class="lineNum">    1313 </span>                :            :  *
<span class="lineNum">    1314 </span>                :            :  * If the caller already has a dbuf in the target object
<span class="lineNum">    1315 </span>                :            :  * (e.g. its bonus buffer), this routine is faster than dmu_read_uio(),
<span class="lineNum">    1316 </span>                :            :  * because we don't have to find the dnode_t for the object.
<span class="lineNum">    1317 </span>                :            :  */
<span class="lineNum">    1318 </span>                :            : int
<span class="lineNum">    1319 </span>                :            : dmu_read_uio_dbuf(dmu_buf_t *zdb, uio_t *uio, uint64_t size)
<span class="lineNum">    1320 </span>                :            : {
<span class="lineNum">    1321 </span>                :            :         dmu_buf_impl_t *db = (dmu_buf_impl_t *)zdb;
<span class="lineNum">    1322 </span>                :            :         dnode_t *dn;
<span class="lineNum">    1323 </span>                :            :         int err;
<span class="lineNum">    1324 </span>                :            : 
<span class="lineNum">    1325 </span>                :            :         if (size == 0)
<span class="lineNum">    1326 </span>                :            :                 return (0);
<span class="lineNum">    1327 </span>                :            : 
<span class="lineNum">    1328 </span>                :            :         DB_DNODE_ENTER(db);
<span class="lineNum">    1329 </span>                :            :         dn = DB_DNODE(db);
<span class="lineNum">    1330 </span>                :            :         err = dmu_read_uio_dnode(dn, uio, size);
<span class="lineNum">    1331 </span>                :            :         DB_DNODE_EXIT(db);
<span class="lineNum">    1332 </span>                :            : 
<span class="lineNum">    1333 </span>                :            :         return (err);
<span class="lineNum">    1334 </span>                :            : }
<span class="lineNum">    1335 </span>                :            : 
<span class="lineNum">    1336 </span>                :            : /*
<span class="lineNum">    1337 </span>                :            :  * Read 'size' bytes into the uio buffer.
<span class="lineNum">    1338 </span>                :            :  * From the specified object
<span class="lineNum">    1339 </span>                :            :  * Starting at offset uio-&gt;uio_loffset.
<span class="lineNum">    1340 </span>                :            :  */
<span class="lineNum">    1341 </span>                :            : int
<span class="lineNum">    1342 </span>                :            : dmu_read_uio(objset_t *os, uint64_t object, uio_t *uio, uint64_t size)
<span class="lineNum">    1343 </span>                :            : {
<span class="lineNum">    1344 </span>                :            :         dnode_t *dn;
<span class="lineNum">    1345 </span>                :            :         int err;
<span class="lineNum">    1346 </span>                :            : 
<span class="lineNum">    1347 </span>                :            :         if (size == 0)
<span class="lineNum">    1348 </span>                :            :                 return (0);
<span class="lineNum">    1349 </span>                :            : 
<span class="lineNum">    1350 </span>                :            :         err = dnode_hold(os, object, FTAG, &amp;dn);
<span class="lineNum">    1351 </span>                :            :         if (err)
<span class="lineNum">    1352 </span>                :            :                 return (err);
<span class="lineNum">    1353 </span>                :            : 
<span class="lineNum">    1354 </span>                :            :         err = dmu_read_uio_dnode(dn, uio, size);
<span class="lineNum">    1355 </span>                :            : 
<span class="lineNum">    1356 </span>                :            :         dnode_rele(dn, FTAG);
<span class="lineNum">    1357 </span>                :            : 
<span class="lineNum">    1358 </span>                :            :         return (err);
<span class="lineNum">    1359 </span>                :            : }
<span class="lineNum">    1360 </span>                :            : 
<span class="lineNum">    1361 </span>                :            : int
<span class="lineNum">    1362 </span>                :            : dmu_write_uio_dnode(dnode_t *dn, uio_t *uio, uint64_t size, dmu_tx_t *tx)
<span class="lineNum">    1363 </span>                :            : {
<span class="lineNum">    1364 </span>                :            :         dmu_buf_t **dbp;
<span class="lineNum">    1365 </span>                :            :         int numbufs;
<span class="lineNum">    1366 </span>                :            :         int err = 0;
<span class="lineNum">    1367 </span>                :            :         int i;
<span class="lineNum">    1368 </span>                :            : 
<span class="lineNum">    1369 </span>                :            :         err = dmu_buf_hold_array_by_dnode(dn, uio-&gt;uio_loffset, size,
<span class="lineNum">    1370 </span>                :            :             FALSE, FTAG, &amp;numbufs, &amp;dbp, DMU_READ_PREFETCH);
<span class="lineNum">    1371 </span>                :            :         if (err)
<span class="lineNum">    1372 </span>                :            :                 return (err);
<span class="lineNum">    1373 </span>                :            : 
<span class="lineNum">    1374 </span>                :            :         for (i = 0; i &lt; numbufs; i++) {
<span class="lineNum">    1375 </span>                :            :                 uint64_t tocpy;
<span class="lineNum">    1376 </span>                :            :                 int64_t bufoff;
<span class="lineNum">    1377 </span>                :            :                 dmu_buf_t *db = dbp[i];
<span class="lineNum">    1378 </span>                :            : 
<span class="lineNum">    1379 </span>                :            :                 ASSERT(size &gt; 0);
<span class="lineNum">    1380 </span>                :            : 
<span class="lineNum">    1381 </span>                :            :                 bufoff = uio-&gt;uio_loffset - db-&gt;db_offset;
<span class="lineNum">    1382 </span>                :            :                 tocpy = MIN(db-&gt;db_size - bufoff, size);
<span class="lineNum">    1383 </span>                :            : 
<span class="lineNum">    1384 </span>                :            :                 ASSERT(i == 0 || i == numbufs-1 || tocpy == db-&gt;db_size);
<span class="lineNum">    1385 </span>                :            : 
<span class="lineNum">    1386 </span>                :            :                 if (tocpy == db-&gt;db_size)
<span class="lineNum">    1387 </span>                :            :                         dmu_buf_will_fill(db, tx);
<span class="lineNum">    1388 </span>                :            :                 else
<span class="lineNum">    1389 </span>                :            :                         dmu_buf_will_dirty(db, tx);
<span class="lineNum">    1390 </span>                :            : 
<span class="lineNum">    1391 </span>                :            :                 /*
<span class="lineNum">    1392 </span>                :            :                  * XXX uiomove could block forever (eg.nfs-backed
<span class="lineNum">    1393 </span>                :            :                  * pages).  There needs to be a uiolockdown() function
<span class="lineNum">    1394 </span>                :            :                  * to lock the pages in memory, so that uiomove won't
<span class="lineNum">    1395 </span>                :            :                  * block.
<span class="lineNum">    1396 </span>                :            :                  */
<span class="lineNum">    1397 </span>                :            :                 err = uiomove((char *)db-&gt;db_data + bufoff, tocpy,
<span class="lineNum">    1398 </span>                :            :                     UIO_WRITE, uio);
<span class="lineNum">    1399 </span>                :            : 
<span class="lineNum">    1400 </span>                :            :                 if (tocpy == db-&gt;db_size)
<span class="lineNum">    1401 </span>                :            :                         dmu_buf_fill_done(db, tx);
<span class="lineNum">    1402 </span>                :            : 
<span class="lineNum">    1403 </span>                :            :                 if (err)
<span class="lineNum">    1404 </span>                :            :                         break;
<span class="lineNum">    1405 </span>                :            : 
<span class="lineNum">    1406 </span>                :            :                 size -= tocpy;
<span class="lineNum">    1407 </span>                :            :         }
<span class="lineNum">    1408 </span>                :            : 
<span class="lineNum">    1409 </span>                :            :         dmu_buf_rele_array(dbp, numbufs, FTAG);
<span class="lineNum">    1410 </span>                :            :         return (err);
<span class="lineNum">    1411 </span>                :            : }
<span class="lineNum">    1412 </span>                :            : 
<span class="lineNum">    1413 </span>                :            : /*
<span class="lineNum">    1414 </span>                :            :  * Write 'size' bytes from the uio buffer.
<span class="lineNum">    1415 </span>                :            :  * To object zdb-&gt;db_object.
<span class="lineNum">    1416 </span>                :            :  * Starting at offset uio-&gt;uio_loffset.
<span class="lineNum">    1417 </span>                :            :  *
<span class="lineNum">    1418 </span>                :            :  * If the caller already has a dbuf in the target object
<span class="lineNum">    1419 </span>                :            :  * (e.g. its bonus buffer), this routine is faster than dmu_write_uio(),
<span class="lineNum">    1420 </span>                :            :  * because we don't have to find the dnode_t for the object.
<span class="lineNum">    1421 </span>                :            :  */
<span class="lineNum">    1422 </span>                :            : int
<span class="lineNum">    1423 </span>                :            : dmu_write_uio_dbuf(dmu_buf_t *zdb, uio_t *uio, uint64_t size,
<span class="lineNum">    1424 </span>                :            :     dmu_tx_t *tx)
<span class="lineNum">    1425 </span>                :            : {
<span class="lineNum">    1426 </span>                :            :         dmu_buf_impl_t *db = (dmu_buf_impl_t *)zdb;
<span class="lineNum">    1427 </span>                :            :         dnode_t *dn;
<span class="lineNum">    1428 </span>                :            :         int err;
<span class="lineNum">    1429 </span>                :            : 
<span class="lineNum">    1430 </span>                :            :         if (size == 0)
<span class="lineNum">    1431 </span>                :            :                 return (0);
<span class="lineNum">    1432 </span>                :            : 
<span class="lineNum">    1433 </span>                :            :         DB_DNODE_ENTER(db);
<span class="lineNum">    1434 </span>                :            :         dn = DB_DNODE(db);
<span class="lineNum">    1435 </span>                :            :         err = dmu_write_uio_dnode(dn, uio, size, tx);
<span class="lineNum">    1436 </span>                :            :         DB_DNODE_EXIT(db);
<span class="lineNum">    1437 </span>                :            : 
<span class="lineNum">    1438 </span>                :            :         return (err);
<span class="lineNum">    1439 </span>                :            : }
<span class="lineNum">    1440 </span>                :            : 
<span class="lineNum">    1441 </span>                :            : /*
<span class="lineNum">    1442 </span>                :            :  * Write 'size' bytes from the uio buffer.
<span class="lineNum">    1443 </span>                :            :  * To the specified object.
<span class="lineNum">    1444 </span>                :            :  * Starting at offset uio-&gt;uio_loffset.
<span class="lineNum">    1445 </span>                :            :  */
<span class="lineNum">    1446 </span>                :            : int
<span class="lineNum">    1447 </span>                :            : dmu_write_uio(objset_t *os, uint64_t object, uio_t *uio, uint64_t size,
<span class="lineNum">    1448 </span>                :            :     dmu_tx_t *tx)
<span class="lineNum">    1449 </span>                :            : {
<span class="lineNum">    1450 </span>                :            :         dnode_t *dn;
<span class="lineNum">    1451 </span>                :            :         int err;
<span class="lineNum">    1452 </span>                :            : 
<span class="lineNum">    1453 </span>                :            :         if (size == 0)
<span class="lineNum">    1454 </span>                :            :                 return (0);
<span class="lineNum">    1455 </span>                :            : 
<span class="lineNum">    1456 </span>                :            :         err = dnode_hold(os, object, FTAG, &amp;dn);
<span class="lineNum">    1457 </span>                :            :         if (err)
<span class="lineNum">    1458 </span>                :            :                 return (err);
<span class="lineNum">    1459 </span>                :            : 
<span class="lineNum">    1460 </span>                :            :         err = dmu_write_uio_dnode(dn, uio, size, tx);
<span class="lineNum">    1461 </span>                :            : 
<span class="lineNum">    1462 </span>                :            :         dnode_rele(dn, FTAG);
<span class="lineNum">    1463 </span>                :            : 
<span class="lineNum">    1464 </span>                :            :         return (err);
<span class="lineNum">    1465 </span>                :            : }
<span class="lineNum">    1466 </span>                :            : #endif /* _KERNEL */
<span class="lineNum">    1467 </span>                :            : 
<span class="lineNum">    1468 </span>                :            : /*
<span class="lineNum">    1469 </span>                :            :  * Allocate a loaned anonymous arc buffer.
<a name="1470"><span class="lineNum">    1470 </span>                :            :  */</a>
<span class="lineNum">    1471 </span>                :            : arc_buf_t *
<span class="lineNum">    1472 </span>                :<span class="lineCov">       5861 : dmu_request_arcbuf(dmu_buf_t *handle, int size)</span>
<span class="lineNum">    1473 </span>                :            : {
<span class="lineNum">    1474 </span>                :<span class="lineCov">       5861 :         dmu_buf_impl_t *db = (dmu_buf_impl_t *)handle;</span>
<span class="lineNum">    1475 </span>                :            : 
<span class="lineNum">    1476 </span>                :<span class="lineCov">       5861 :         return (arc_loan_buf(db-&gt;db_objset-&gt;os_spa, B_FALSE, size));</span>
<span class="lineNum">    1477 </span>                :            : }
<span class="lineNum">    1478 </span>                :            : 
<span class="lineNum">    1479 </span>                :            : /*
<span class="lineNum">    1480 </span>                :            :  * Free a loaned arc buffer.
<a name="1481"><span class="lineNum">    1481 </span>                :            :  */</a>
<span class="lineNum">    1482 </span>                :            : void
<span class="lineNum">    1483 </span>                :<span class="lineCov">       1203 : dmu_return_arcbuf(arc_buf_t *buf)</span>
<span class="lineNum">    1484 </span>                :            : {
<span class="lineNum">    1485 </span>                :<span class="lineCov">       1203 :         arc_return_buf(buf, FTAG);</span>
<span class="lineNum">    1486 </span>                :<span class="lineCov">       1203 :         arc_buf_destroy(buf, FTAG);</span>
<span class="lineNum">    1487 </span>                :<span class="lineCov">       1203 : }</span>
<a name="1488"><span class="lineNum">    1488 </span>                :            : </a>
<span class="lineNum">    1489 </span>                :            : void
<span class="lineNum">    1490 </span>                :<span class="lineNoCov">          0 : dmu_assign_arcbuf_impl(dmu_buf_t *handle, arc_buf_t *buf, dmu_tx_t *tx)</span>
<span class="lineNum">    1491 </span>                :            : {
<span class="lineNum">    1492 </span>                :<span class="lineNoCov">          0 :         dmu_buf_impl_t *db = (dmu_buf_impl_t *)handle;</span>
<span class="lineNum">    1493 </span>                :<span class="lineNoCov">          0 :         dbuf_assign_arcbuf(db, buf, tx);</span>
<span class="lineNum">    1494 </span>                :<span class="lineNoCov">          0 : }</span>
<a name="1495"><span class="lineNum">    1495 </span>                :            : </a>
<span class="lineNum">    1496 </span>                :            : void
<span class="lineNum">    1497 </span>                :<span class="lineNoCov">          0 : dmu_convert_to_raw(dmu_buf_t *handle, boolean_t byteorder, const uint8_t *salt,</span>
<span class="lineNum">    1498 </span>                :            :     const uint8_t *iv, const uint8_t *mac, dmu_tx_t *tx)
<span class="lineNum">    1499 </span>                :            : {
<span class="lineNum">    1500 </span>                :            :         dmu_object_type_t type;
<span class="lineNum">    1501 </span>                :<span class="lineNoCov">          0 :         dmu_buf_impl_t *db = (dmu_buf_impl_t *)handle;</span>
<span class="lineNum">    1502 </span>                :<span class="lineNoCov">          0 :         uint64_t dsobj = dmu_objset_id(db-&gt;db_objset);</span>
<span class="lineNum">    1503 </span>                :            : 
<span class="lineNum">    1504 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :         ASSERT3P(db-&gt;db_buf, !=, NULL);</span>
<span class="lineNum">    1505 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :         ASSERT3U(dsobj, !=, 0);</span>
<span class="lineNum">    1506 </span>                :            : 
<span class="lineNum">    1507 </span>                :<span class="lineNoCov">          0 :         dmu_buf_will_change_crypt_params(handle, tx);</span>
<span class="lineNum">    1508 </span>                :            : 
<span class="lineNum">    1509 </span>                :<span class="lineNoCov">          0 :         DB_DNODE_ENTER(db);</span>
<span class="lineNum">    1510 </span>                :<span class="lineNoCov">          0 :         type = DB_DNODE(db)-&gt;dn_type;</span>
<span class="lineNum">    1511 </span>                :<span class="lineNoCov">          0 :         DB_DNODE_EXIT(db);</span>
<span class="lineNum">    1512 </span>                :            : 
<span class="lineNum">    1513 </span>                :            :         /*
<span class="lineNum">    1514 </span>                :            :          * This technically violates the assumption the dmu code makes
<span class="lineNum">    1515 </span>                :            :          * that dnode blocks are only released in syncing context.
<span class="lineNum">    1516 </span>                :            :          */
<span class="lineNum">    1517 </span>                :<span class="lineNoCov">          0 :         (void) arc_release(db-&gt;db_buf, db);</span>
<span class="lineNum">    1518 </span>                :<span class="lineNoCov">          0 :         arc_convert_to_raw(db-&gt;db_buf, dsobj, byteorder, type, salt, iv, mac);</span>
<span class="lineNum">    1519 </span>                :<span class="lineNoCov">          0 : }</span>
<a name="1520"><span class="lineNum">    1520 </span>                :            : </a>
<span class="lineNum">    1521 </span>                :            : void
<span class="lineNum">    1522 </span>                :<span class="lineNoCov">          0 : dmu_copy_from_buf(objset_t *os, uint64_t object, uint64_t offset,</span>
<span class="lineNum">    1523 </span>                :            :     dmu_buf_t *handle, dmu_tx_t *tx)
<span class="lineNum">    1524 </span>                :            : {
<span class="lineNum">    1525 </span>                :            :         dmu_buf_t *dst_handle;
<span class="lineNum">    1526 </span>                :            :         dmu_buf_impl_t *dstdb;
<span class="lineNum">    1527 </span>                :<span class="lineNoCov">          0 :         dmu_buf_impl_t *srcdb = (dmu_buf_impl_t *)handle;</span>
<span class="lineNum">    1528 </span>                :            :         arc_buf_t *abuf;
<span class="lineNum">    1529 </span>                :            :         uint64_t datalen;
<span class="lineNum">    1530 </span>                :            :         boolean_t byteorder;
<span class="lineNum">    1531 </span>                :            :         uint8_t salt[ZIO_DATA_SALT_LEN];
<span class="lineNum">    1532 </span>                :            :         uint8_t iv[ZIO_DATA_IV_LEN];
<span class="lineNum">    1533 </span>                :            :         uint8_t mac[ZIO_DATA_MAC_LEN];
<span class="lineNum">    1534 </span>                :            : 
<span class="lineNum">    1535 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :         ASSERT3P(srcdb-&gt;db_buf, !=, NULL);</span>
<span class="lineNum">    1536 </span>                :            : 
<span class="lineNum">    1537 </span>                :            :         /* hold the db that we want to write to */
<span class="lineNum">    1538 </span>        [<span class="branchNoExec" title="Branch 1 was not executed"> # </span><span class="branchNoExec" title="Branch 2 was not executed"> # </span>]:<span class="lineNoCov">          0 :         VERIFY0(dmu_buf_hold(os, object, offset, FTAG, &amp;dst_handle,</span>
<span class="lineNum">    1539 </span>                :            :             DMU_READ_NO_DECRYPT));
<span class="lineNum">    1540 </span>                :<span class="lineNoCov">          0 :         dstdb = (dmu_buf_impl_t *)dst_handle;</span>
<span class="lineNum">    1541 </span>                :<span class="lineNoCov">          0 :         datalen = arc_buf_size(srcdb-&gt;db_buf);</span>
<span class="lineNum">    1542 </span>                :            : 
<span class="lineNum">    1543 </span>                :            :         /* allocated an arc buffer that matches the type of srcdb-&gt;db_buf */
<span class="lineNum">    1544 </span>        [<span class="branchNoExec" title="Branch 1 was not executed"> # </span><span class="branchNoExec" title="Branch 2 was not executed"> # </span>]:<span class="lineNoCov">          0 :         if (arc_is_encrypted(srcdb-&gt;db_buf)) {</span>
<span class="lineNum">    1545 </span>                :<span class="lineNoCov">          0 :                 arc_get_raw_params(srcdb-&gt;db_buf, &amp;byteorder, salt, iv, mac);</span>
<span class="lineNum">    1546 </span>                :<span class="lineNoCov">          0 :                 abuf = arc_loan_raw_buf(os-&gt;os_spa, dmu_objset_id(os),</span>
<span class="lineNum">    1547 </span>                :<span class="lineNoCov">          0 :                     byteorder, salt, iv, mac, DB_DNODE(dstdb)-&gt;dn_type,</span>
<span class="lineNum">    1548 </span>                :            :                     datalen, arc_buf_lsize(srcdb-&gt;db_buf),
<span class="lineNum">    1549 </span>                :            :                     arc_get_compression(srcdb-&gt;db_buf));
<span class="lineNum">    1550 </span>                :            :         } else {
<span class="lineNum">    1551 </span>                :            :                 /* we won't get a compressed db back from dmu_buf_hold() */
<span class="lineNum">    1552 </span>        [<span class="branchNoExec" title="Branch 1 was not executed"> # </span><span class="branchNoExec" title="Branch 2 was not executed"> # </span>]:<span class="lineNoCov">          0 :                 ASSERT3U(arc_get_compression(srcdb-&gt;db_buf),</span>
<span class="lineNum">    1553 </span>                :            :                     ==, ZIO_COMPRESS_OFF);
<span class="lineNum">    1554 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :                 abuf = arc_loan_buf(os-&gt;os_spa,</span>
<span class="lineNum">    1555 </span>                :<span class="lineNoCov">          0 :                     DMU_OT_IS_METADATA(DB_DNODE(dstdb)-&gt;dn_type), datalen);</span>
<span class="lineNum">    1556 </span>                :            :         }
<span class="lineNum">    1557 </span>                :            : 
<span class="lineNum">    1558 </span>        [<span class="branchNoExec" title="Branch 1 was not executed"> # </span><span class="branchNoExec" title="Branch 2 was not executed"> # </span>]:<span class="lineNoCov">          0 :         ASSERT3U(datalen, ==, arc_buf_size(abuf));</span>
<span class="lineNum">    1559 </span>                :            : 
<span class="lineNum">    1560 </span>                :            :         /* copy the data to the new buffer and assign it to the dstdb */
<span class="lineNum">    1561 </span>                :<span class="lineNoCov">          0 :         bcopy(srcdb-&gt;db_buf-&gt;b_data, abuf-&gt;b_data, datalen);</span>
<span class="lineNum">    1562 </span>                :<span class="lineNoCov">          0 :         dbuf_assign_arcbuf(dstdb, abuf, tx);</span>
<span class="lineNum">    1563 </span>                :<span class="lineNoCov">          0 :         dmu_buf_rele(dst_handle, FTAG);</span>
<span class="lineNum">    1564 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1565 </span>                :            : 
<span class="lineNum">    1566 </span>                :            : /*
<span class="lineNum">    1567 </span>                :            :  * When possible directly assign passed loaned arc buffer to a dbuf.
<span class="lineNum">    1568 </span>                :            :  * If this is not possible copy the contents of passed arc buf via
<span class="lineNum">    1569 </span>                :            :  * dmu_write().
<a name="1570"><span class="lineNum">    1570 </span>                :            :  */</a>
<span class="lineNum">    1571 </span>                :            : void
<span class="lineNum">    1572 </span>                :<span class="lineCov">       5530 : dmu_assign_arcbuf(dmu_buf_t *handle, uint64_t offset, arc_buf_t *buf,</span>
<span class="lineNum">    1573 </span>                :            :     dmu_tx_t *tx)
<span class="lineNum">    1574 </span>                :            : {
<span class="lineNum">    1575 </span>                :<span class="lineCov">       5530 :         dmu_buf_impl_t *dbuf = (dmu_buf_impl_t *)handle;</span>
<span class="lineNum">    1576 </span>                :            :         dnode_t *dn;
<span class="lineNum">    1577 </span>                :            :         dmu_buf_impl_t *db;
<span class="lineNum">    1578 </span>                :<span class="lineCov">       5530 :         uint32_t blksz = (uint32_t)arc_buf_lsize(buf);</span>
<span class="lineNum">    1579 </span>                :            :         uint64_t blkid;
<span class="lineNum">    1580 </span>                :            : 
<span class="lineNum">    1581 </span>                :<span class="lineCov">       5530 :         DB_DNODE_ENTER(dbuf);</span>
<span class="lineNum">    1582 </span>                :<span class="lineCov">       5530 :         dn = DB_DNODE(dbuf);</span>
<span class="lineNum">    1583 </span>                :<span class="lineCov">       5530 :         rw_enter(&amp;dn-&gt;dn_struct_rwlock, RW_READER);</span>
<span class="lineNum">    1584 </span>                :<span class="lineCov">       5530 :         blkid = dbuf_whichblock(dn, 0, offset);</span>
<span class="lineNum">    1585 </span>        [<span class="branchNoCov" title="Branch 1 was not taken"> - </span><span class="branchCov" title="Branch 2 was taken 5530 times"> + </span>]:<span class="lineCov">       5530 :         VERIFY((db = dbuf_hold(dn, blkid, FTAG)) != NULL);</span>
<span class="lineNum">    1586 </span>                :<span class="lineCov">       5530 :         rw_exit(&amp;dn-&gt;dn_struct_rwlock);</span>
<span class="lineNum">    1587 </span>                :<span class="lineCov">       5530 :         DB_DNODE_EXIT(dbuf);</span>
<span class="lineNum">    1588 </span>                :            : 
<span class="lineNum">    1589 </span>                :            :         /*
<span class="lineNum">    1590 </span>                :            :          * We can only assign if the offset is aligned, the arc buf is the
<span class="lineNum">    1591 </span>                :            :          * same size as the dbuf, and the dbuf is not metadata.
<span class="lineNum">    1592 </span>                :            :          */
<span class="lineNum">    1593 </span>[<span class="branchCov" title="Branch 0 was taken 5094 times"> + </span><span class="branchCov" title="Branch 1 was taken 436 times"> + </span>][<span class="branchCov" title="Branch 2 was taken 4658 times"> + </span><span class="branchCov" title="Branch 3 was taken 436 times"> + </span>]:<span class="lineCov">       5530 :         if (offset == db-&gt;db.db_offset &amp;&amp; blksz == db-&gt;db.db_size) {</span>
<span class="lineNum">    1594 </span>                :<span class="lineCov">       4658 :                 dbuf_assign_arcbuf(db, buf, tx);</span>
<span class="lineNum">    1595 </span>                :<span class="lineCov">       4658 :                 dbuf_rele(db, FTAG);</span>
<span class="lineNum">    1596 </span>                :            :         } else {
<span class="lineNum">    1597 </span>                :            :                 objset_t *os;
<span class="lineNum">    1598 </span>                :            :                 uint64_t object;
<span class="lineNum">    1599 </span>                :            : 
<span class="lineNum">    1600 </span>                :            :                 /* compressed bufs must always be assignable to their dbuf */
<span class="lineNum">    1601 </span>        [<span class="branchNoCov" title="Branch 1 was not taken"> - </span><span class="branchCov" title="Branch 2 was taken 872 times"> + </span>]:<span class="lineCov">        872 :                 ASSERT3U(arc_get_compression(buf), ==, ZIO_COMPRESS_OFF);</span>
<span class="lineNum">    1602 </span>        [<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 872 times"> + </span>]:<span class="lineCov">        872 :                 ASSERT(!(buf-&gt;b_flags &amp; ARC_BUF_FLAG_COMPRESSED));</span>
<span class="lineNum">    1603 </span>                :            : 
<span class="lineNum">    1604 </span>                :<span class="lineCov">        872 :                 DB_DNODE_ENTER(dbuf);</span>
<span class="lineNum">    1605 </span>                :<span class="lineCov">        872 :                 dn = DB_DNODE(dbuf);</span>
<span class="lineNum">    1606 </span>                :<span class="lineCov">        872 :                 os = dn-&gt;dn_objset;</span>
<span class="lineNum">    1607 </span>                :<span class="lineCov">        872 :                 object = dn-&gt;dn_object;</span>
<span class="lineNum">    1608 </span>                :<span class="lineCov">        872 :                 DB_DNODE_EXIT(dbuf);</span>
<span class="lineNum">    1609 </span>                :            : 
<span class="lineNum">    1610 </span>                :<span class="lineCov">        872 :                 dbuf_rele(db, FTAG);</span>
<span class="lineNum">    1611 </span>                :<span class="lineCov">        872 :                 dmu_write(os, object, offset, blksz, buf-&gt;b_data, tx);</span>
<span class="lineNum">    1612 </span>                :<span class="lineCov">        872 :                 dmu_return_arcbuf(buf);</span>
<span class="lineNum">    1613 </span>                :<span class="lineCov">        872 :                 XUIOSTAT_BUMP(xuiostat_wbuf_copied);</span>
<span class="lineNum">    1614 </span>                :            :         }
<span class="lineNum">    1615 </span>                :<span class="lineCov">       5530 : }</span>
<span class="lineNum">    1616 </span>                :            : 
<span class="lineNum">    1617 </span>                :            : typedef struct {
<span class="lineNum">    1618 </span>                :            :         dbuf_dirty_record_t     *dsa_dr;
<span class="lineNum">    1619 </span>                :            :         dmu_sync_cb_t           *dsa_done;
<span class="lineNum">    1620 </span>                :            :         zgd_t                   *dsa_zgd;
<span class="lineNum">    1621 </span>                :            :         dmu_tx_t                *dsa_tx;
<span class="lineNum">    1622 </span>                :            : } dmu_sync_arg_t;
<span class="lineNum">    1623 </span>                :            : 
<a name="1624"><span class="lineNum">    1624 </span>                :            : /* ARGSUSED */</a>
<span class="lineNum">    1625 </span>                :            : static void
<span class="lineNum">    1626 </span>                :<span class="lineCov">        141 : dmu_sync_ready(zio_t *zio, arc_buf_t *buf, void *varg)</span>
<span class="lineNum">    1627 </span>                :            : {
<span class="lineNum">    1628 </span>                :<span class="lineCov">        141 :         dmu_sync_arg_t *dsa = varg;</span>
<span class="lineNum">    1629 </span>                :<span class="lineCov">        141 :         dmu_buf_t *db = dsa-&gt;dsa_zgd-&gt;zgd_db;</span>
<span class="lineNum">    1630 </span>                :<span class="lineCov">        141 :         blkptr_t *bp = zio-&gt;io_bp;</span>
<span class="lineNum">    1631 </span>                :            : 
<span class="lineNum">    1632 </span>        [<span class="branchCov" title="Branch 0 was taken 141 times"> + </span><span class="branchNoCov" title="Branch 1 was not taken"> - </span>]:<span class="lineCov">        141 :         if (zio-&gt;io_error == 0) {</span>
<span class="lineNum">    1633 </span>[<span class="branchCov" title="Branch 0 was taken 83 times"> + </span><span class="branchCov" title="Branch 1 was taken 58 times"> + </span>][<span class="branchCov" title="Branch 2 was taken 32 times"> + </span><span class="branchCov" title="Branch 3 was taken 51 times"> + </span>]:<span class="lineCov">        141 :                 if (BP_IS_HOLE(bp)) {</span>
<span class="lineNum">         </span>        [<span class="branchCov" title="Branch 4 was taken 32 times"> + </span><span class="branchNoCov" title="Branch 5 was not taken"> - </span>]
<span class="lineNum">    1634 </span>                :            :                         /*
<span class="lineNum">    1635 </span>                :            :                          * A block of zeros may compress to a hole, but the
<span class="lineNum">    1636 </span>                :            :                          * block size still needs to be known for replay.
<span class="lineNum">    1637 </span>                :            :                          */
<span class="lineNum">    1638 </span>[<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 32 times"> + </span>][<span class="branchNoCov" title="Branch 3 was not taken"> - </span><span class="branchCov" title="Branch 4 was taken 32 times"> + </span>]:<span class="lineCov">         32 :                         BP_SET_LSIZE(bp, db-&gt;db_size);</span>
<span class="lineNum">         </span>        [<span class="branchNoCov" title="Branch 6 was not taken"> - </span><span class="branchCov" title="Branch 7 was taken 32 times"> + </span>]
<span class="lineNum">    1639 </span>        [<span class="branchCov" title="Branch 0 was taken 51 times"> + </span><span class="branchCov" title="Branch 1 was taken 58 times"> + </span>]:<span class="lineCov">        109 :                 } else if (!BP_IS_EMBEDDED(bp)) {</span>
<span class="lineNum">    1640 </span>        [<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 51 times"> + </span>]:<span class="lineCov">         51 :                         ASSERT(BP_GET_LEVEL(bp) == 0);</span>
<span class="lineNum">    1641 </span>[<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 51 times"> + </span>][<span class="branchNoExec" title="Branch 2 was not executed"> # </span><span class="branchNoExec" title="Branch 3 was not executed"> # </span>]:<span class="lineCov">         51 :                         BP_SET_FILL(bp, 1);</span>
<span class="lineNum">         </span>[<span class="branchNoExec" title="Branch 4 was not executed"> # </span><span class="branchNoExec" title="Branch 5 was not executed"> # </span>][<span class="branchNoExec" title="Branch 6 was not executed"> # </span><span class="branchNoExec" title="Branch 7 was not executed"> # </span>]
<span class="lineNum">    1642 </span>                :            :                 }
<span class="lineNum">    1643 </span>                :            :         }
<span class="lineNum">    1644 </span>                :<span class="lineCov">        141 : }</span>
<a name="1645"><span class="lineNum">    1645 </span>                :            : </a>
<span class="lineNum">    1646 </span>                :            : static void
<span class="lineNum">    1647 </span>                :<span class="lineCov">        105 : dmu_sync_late_arrival_ready(zio_t *zio)</span>
<span class="lineNum">    1648 </span>                :            : {
<span class="lineNum">    1649 </span>                :<span class="lineCov">        105 :         dmu_sync_ready(zio, NULL, zio-&gt;io_private);</span>
<span class="lineNum">    1650 </span>                :<span class="lineCov">        105 : }</span>
<span class="lineNum">    1651 </span>                :            : 
<a name="1652"><span class="lineNum">    1652 </span>                :            : /* ARGSUSED */</a>
<span class="lineNum">    1653 </span>                :            : static void
<span class="lineNum">    1654 </span>                :<span class="lineCov">         36 : dmu_sync_done(zio_t *zio, arc_buf_t *buf, void *varg)</span>
<span class="lineNum">    1655 </span>                :            : {
<span class="lineNum">    1656 </span>                :<span class="lineCov">         36 :         dmu_sync_arg_t *dsa = varg;</span>
<span class="lineNum">    1657 </span>                :<span class="lineCov">         36 :         dbuf_dirty_record_t *dr = dsa-&gt;dsa_dr;</span>
<span class="lineNum">    1658 </span>                :<span class="lineCov">         36 :         dmu_buf_impl_t *db = dr-&gt;dr_dbuf;</span>
<span class="lineNum">    1659 </span>                :            : 
<span class="lineNum">    1660 </span>                :<span class="lineCov">         36 :         mutex_enter(&amp;db-&gt;db_mtx);</span>
<span class="lineNum">    1661 </span>        [<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 36 times"> + </span>]:<span class="lineCov">         36 :         ASSERT(dr-&gt;dt.dl.dr_override_state == DR_IN_DMU_SYNC);</span>
<span class="lineNum">    1662 </span>        [<span class="branchCov" title="Branch 0 was taken 36 times"> + </span><span class="branchNoCov" title="Branch 1 was not taken"> - </span>]:<span class="lineCov">         36 :         if (zio-&gt;io_error == 0) {</span>
<span class="lineNum">    1663 </span>                :<span class="lineCov">         36 :                 dr-&gt;dt.dl.dr_nopwrite = !!(zio-&gt;io_flags &amp; ZIO_FLAG_NOPWRITE);</span>
<span class="lineNum">    1664 </span>        [<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 36 times"> + </span>]:<span class="lineCov">         36 :                 if (dr-&gt;dt.dl.dr_nopwrite) {</span>
<span class="lineNum">    1665 </span>                :<span class="lineNoCov">          0 :                         blkptr_t *bp = zio-&gt;io_bp;</span>
<span class="lineNum">    1666 </span>                :<span class="lineNoCov">          0 :                         blkptr_t *bp_orig = &amp;zio-&gt;io_bp_orig;</span>
<span class="lineNum">    1667 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :                         uint8_t chksum = BP_GET_CHECKSUM(bp_orig);</span>
<span class="lineNum">    1668 </span>                :            : 
<span class="lineNum">    1669 </span>[<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>][<span class="branchNoExec" title="Branch 2 was not executed"> # </span><span class="branchNoExec" title="Branch 3 was not executed"> # </span>]:<span class="lineNoCov">          0 :                         ASSERT(BP_EQUAL(bp, bp_orig));</span>
<span class="lineNum">         </span>[<span class="branchNoExec" title="Branch 4 was not executed"> # </span><span class="branchNoExec" title="Branch 5 was not executed"> # </span>][<span class="branchNoExec" title="Branch 6 was not executed"> # </span><span class="branchNoExec" title="Branch 7 was not executed"> # </span>]
<span class="lineNum">         </span>[<span class="branchNoExec" title="Branch 8 was not executed"> # </span><span class="branchNoExec" title="Branch 9 was not executed"> # </span>][<span class="branchNoExec" title="Branch 10 was not executed"> # </span><span class="branchNoExec" title="Branch 11 was not executed"> # </span>]
<span class="lineNum">         </span>[<span class="branchNoExec" title="Branch 12 was not executed"> # </span><span class="branchNoExec" title="Branch 13 was not executed"> # </span>][<span class="branchNoExec" title="Branch 14 was not executed"> # </span><span class="branchNoExec" title="Branch 15 was not executed"> # </span>]
<span class="lineNum">         </span>[<span class="branchNoExec" title="Branch 16 was not executed"> # </span><span class="branchNoExec" title="Branch 17 was not executed"> # </span>][<span class="branchNoExec" title="Branch 18 was not executed"> # </span><span class="branchNoExec" title="Branch 19 was not executed"> # </span>]
<span class="lineNum">         </span>[<span class="branchNoExec" title="Branch 20 was not executed"> # </span><span class="branchNoExec" title="Branch 21 was not executed"> # </span>][<span class="branchNoExec" title="Branch 22 was not executed"> # </span><span class="branchNoExec" title="Branch 23 was not executed"> # </span>]
<span class="lineNum">    1670 </span>[<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>][<span class="branchNoExec" title="Branch 2 was not executed"> # </span><span class="branchNoExec" title="Branch 3 was not executed"> # </span>]:<span class="lineNoCov">          0 :                         VERIFY(BP_EQUAL(bp, db-&gt;db_blkptr));</span>
<span class="lineNum">         </span>[<span class="branchNoExec" title="Branch 4 was not executed"> # </span><span class="branchNoExec" title="Branch 5 was not executed"> # </span>][<span class="branchNoExec" title="Branch 6 was not executed"> # </span><span class="branchNoExec" title="Branch 7 was not executed"> # </span>]
<span class="lineNum">         </span>[<span class="branchNoExec" title="Branch 8 was not executed"> # </span><span class="branchNoExec" title="Branch 9 was not executed"> # </span>][<span class="branchNoExec" title="Branch 10 was not executed"> # </span><span class="branchNoExec" title="Branch 11 was not executed"> # </span>]
<span class="lineNum">         </span>[<span class="branchNoExec" title="Branch 12 was not executed"> # </span><span class="branchNoExec" title="Branch 13 was not executed"> # </span>][<span class="branchNoExec" title="Branch 14 was not executed"> # </span><span class="branchNoExec" title="Branch 15 was not executed"> # </span>]
<span class="lineNum">         </span>[<span class="branchNoExec" title="Branch 16 was not executed"> # </span><span class="branchNoExec" title="Branch 17 was not executed"> # </span>][<span class="branchNoExec" title="Branch 18 was not executed"> # </span><span class="branchNoExec" title="Branch 19 was not executed"> # </span>]
<span class="lineNum">    1671 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :                         ASSERT(zio-&gt;io_prop.zp_compress != ZIO_COMPRESS_OFF);</span>
<span class="lineNum">    1672 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :                         VERIFY(zio_checksum_table[chksum].ci_flags &amp;</span>
<span class="lineNum">    1673 </span>                :            :                             ZCHECKSUM_FLAG_NOPWRITE);
<span class="lineNum">    1674 </span>                :            :                 }
<span class="lineNum">    1675 </span>                :<span class="lineCov">         36 :                 dr-&gt;dt.dl.dr_overridden_by = *zio-&gt;io_bp;</span>
<span class="lineNum">    1676 </span>                :<span class="lineCov">         36 :                 dr-&gt;dt.dl.dr_override_state = DR_OVERRIDDEN;</span>
<span class="lineNum">    1677 </span>                :<span class="lineCov">         36 :                 dr-&gt;dt.dl.dr_copies = zio-&gt;io_prop.zp_copies;</span>
<span class="lineNum">    1678 </span>                :            : 
<span class="lineNum">    1679 </span>                :            :                 /*
<span class="lineNum">    1680 </span>                :            :                  * Old style holes are filled with all zeros, whereas
<span class="lineNum">    1681 </span>                :            :                  * new-style holes maintain their lsize, type, level,
<span class="lineNum">    1682 </span>                :            :                  * and birth time (see zio_write_compress). While we
<span class="lineNum">    1683 </span>                :            :                  * need to reset the BP_SET_LSIZE() call that happened
<span class="lineNum">    1684 </span>                :            :                  * in dmu_sync_ready for old style holes, we do *not*
<span class="lineNum">    1685 </span>                :            :                  * want to wipe out the information contained in new
<span class="lineNum">    1686 </span>                :            :                  * style holes. Thus, only zero out the block pointer if
<span class="lineNum">    1687 </span>                :            :                  * it's an old style hole.
<span class="lineNum">    1688 </span>                :            :                  */
<span class="lineNum">    1689 </span>[<span class="branchCov" title="Branch 0 was taken 18 times"> + </span><span class="branchCov" title="Branch 1 was taken 18 times"> + </span>][<span class="branchCov" title="Branch 2 was taken 8 times"> + </span><span class="branchCov" title="Branch 3 was taken 10 times"> + </span>]:<span class="lineCov">         36 :                 if (BP_IS_HOLE(&amp;dr-&gt;dt.dl.dr_overridden_by) &amp;&amp;</span>
<span class="lineNum">         </span>[<span class="branchCov" title="Branch 4 was taken 8 times"> + </span><span class="branchNoCov" title="Branch 5 was not taken"> - </span>][<span class="branchCov" title="Branch 6 was taken 4 times"> + </span><span class="branchCov" title="Branch 7 was taken 4 times"> + </span>]
<span class="lineNum">    1690 </span>                :<span class="lineCov">          8 :                     dr-&gt;dt.dl.dr_overridden_by.blk_birth == 0)</span>
<span class="lineNum">    1691 </span>                :<span class="lineCov">          4 :                         BP_ZERO(&amp;dr-&gt;dt.dl.dr_overridden_by);</span>
<span class="lineNum">    1692 </span>                :            :         } else {
<span class="lineNum">    1693 </span>                :<span class="lineNoCov">          0 :                 dr-&gt;dt.dl.dr_override_state = DR_NOT_OVERRIDDEN;</span>
<span class="lineNum">    1694 </span>                :            :         }
<span class="lineNum">    1695 </span>                :<span class="lineCov">         36 :         cv_broadcast(&amp;db-&gt;db_changed);</span>
<span class="lineNum">    1696 </span>                :<span class="lineCov">         36 :         mutex_exit(&amp;db-&gt;db_mtx);</span>
<span class="lineNum">    1697 </span>                :            : 
<span class="lineNum">    1698 </span>                :<span class="lineCov">         36 :         dsa-&gt;dsa_done(dsa-&gt;dsa_zgd, zio-&gt;io_error);</span>
<span class="lineNum">    1699 </span>                :            : 
<span class="lineNum">    1700 </span>                :<span class="lineCov">         36 :         kmem_free(dsa, sizeof (*dsa));</span>
<span class="lineNum">    1701 </span>                :<span class="lineCov">         36 : }</span>
<a name="1702"><span class="lineNum">    1702 </span>                :            : </a>
<span class="lineNum">    1703 </span>                :            : static void
<span class="lineNum">    1704 </span>                :<span class="lineCov">        105 : dmu_sync_late_arrival_done(zio_t *zio)</span>
<span class="lineNum">    1705 </span>                :            : {
<span class="lineNum">    1706 </span>                :<span class="lineCov">        105 :         blkptr_t *bp = zio-&gt;io_bp;</span>
<span class="lineNum">    1707 </span>                :<span class="lineCov">        105 :         dmu_sync_arg_t *dsa = zio-&gt;io_private;</span>
<span class="lineNum">    1708 </span>                :<span class="lineCov">        105 :         ASSERTV(blkptr_t *bp_orig = &amp;zio-&gt;io_bp_orig);</span>
<span class="lineNum">    1709 </span>                :            : 
<span class="lineNum">    1710 </span>[<span class="branchCov" title="Branch 0 was taken 105 times"> + </span><span class="branchNoCov" title="Branch 1 was not taken"> - </span>][<span class="branchCov" title="Branch 2 was taken 65 times"> + </span><span class="branchCov" title="Branch 3 was taken 40 times"> + </span>]:<span class="lineCov">        105 :         if (zio-&gt;io_error == 0 &amp;&amp; !BP_IS_HOLE(bp)) {</span>
<span class="lineNum">         </span>[<span class="branchCov" title="Branch 4 was taken 24 times"> + </span><span class="branchCov" title="Branch 5 was taken 41 times"> + </span>][<span class="branchNoCov" title="Branch 6 was not taken"> - </span><span class="branchCov" title="Branch 7 was taken 24 times"> + </span>]
<span class="lineNum">    1711 </span>        [<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 81 times"> + </span>]:<span class="lineCov">         81 :                 ASSERT(!(zio-&gt;io_flags &amp; ZIO_FLAG_NOPWRITE));</span>
<span class="lineNum">    1712 </span>[<span class="branchCov" title="Branch 0 was taken 81 times"> + </span><span class="branchNoCov" title="Branch 1 was not taken"> - </span>][<span class="branchCov" title="Branch 2 was taken 81 times"> + </span><span class="branchNoCov" title="Branch 3 was not taken"> - </span>]:<span class="lineCov">         81 :                 ASSERT(BP_IS_HOLE(bp_orig) || !BP_EQUAL(bp, bp_orig));</span>
<span class="lineNum">         </span>[<span class="branchNoCov" title="Branch 4 was not taken"> - </span><span class="branchCov" title="Branch 5 was taken 81 times"> + </span>][<span class="branchNoExec" title="Branch 6 was not executed"> # </span><span class="branchNoExec" title="Branch 7 was not executed"> # </span>]
<span class="lineNum">         </span>[<span class="branchNoExec" title="Branch 8 was not executed"> # </span><span class="branchNoExec" title="Branch 9 was not executed"> # </span>][<span class="branchNoExec" title="Branch 10 was not executed"> # </span><span class="branchNoExec" title="Branch 11 was not executed"> # </span>]
<span class="lineNum">         </span>[<span class="branchNoExec" title="Branch 12 was not executed"> # </span><span class="branchNoExec" title="Branch 13 was not executed"> # </span>][<span class="branchNoExec" title="Branch 14 was not executed"> # </span><span class="branchNoExec" title="Branch 15 was not executed"> # </span>]
<span class="lineNum">         </span>[<span class="branchNoExec" title="Branch 16 was not executed"> # </span><span class="branchNoExec" title="Branch 17 was not executed"> # </span>][<span class="branchNoExec" title="Branch 18 was not executed"> # </span><span class="branchNoExec" title="Branch 19 was not executed"> # </span>]
<span class="lineNum">         </span>[<span class="branchNoExec" title="Branch 20 was not executed"> # </span><span class="branchNoExec" title="Branch 21 was not executed"> # </span>][<span class="branchNoExec" title="Branch 22 was not executed"> # </span><span class="branchNoExec" title="Branch 23 was not executed"> # </span>]
<span class="lineNum">         </span>[<span class="branchNoExec" title="Branch 24 was not executed"> # </span><span class="branchNoExec" title="Branch 25 was not executed"> # </span>][<span class="branchNoExec" title="Branch 26 was not executed"> # </span><span class="branchNoExec" title="Branch 27 was not executed"> # </span>]
<span class="lineNum">         </span>        [<span class="branchNoExec" title="Branch 28 was not executed"> # </span><span class="branchNoExec" title="Branch 29 was not executed"> # </span>]
<span class="lineNum">    1713 </span>        [<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 81 times"> + </span>]:<span class="lineCov">         81 :                 ASSERT(zio-&gt;io_bp-&gt;blk_birth == zio-&gt;io_txg);</span>
<span class="lineNum">    1714 </span>        [<span class="branchNoCov" title="Branch 1 was not taken"> - </span><span class="branchCov" title="Branch 2 was taken 81 times"> + </span>]:<span class="lineCov">         81 :                 ASSERT(zio-&gt;io_txg &gt; spa_syncing_txg(zio-&gt;io_spa));</span>
<span class="lineNum">    1715 </span>                :<span class="lineCov">         81 :                 zio_free(zio-&gt;io_spa, zio-&gt;io_txg, zio-&gt;io_bp);</span>
<span class="lineNum">    1716 </span>                :            :         }
<span class="lineNum">    1717 </span>                :            : 
<span class="lineNum">    1718 </span>                :<span class="lineCov">        105 :         dmu_tx_commit(dsa-&gt;dsa_tx);</span>
<span class="lineNum">    1719 </span>                :            : 
<span class="lineNum">    1720 </span>                :<span class="lineCov">        105 :         dsa-&gt;dsa_done(dsa-&gt;dsa_zgd, zio-&gt;io_error);</span>
<span class="lineNum">    1721 </span>                :            : 
<span class="lineNum">    1722 </span>                :<span class="lineCov">        105 :         abd_put(zio-&gt;io_abd);</span>
<span class="lineNum">    1723 </span>                :<span class="lineCov">        105 :         kmem_free(dsa, sizeof (*dsa));</span>
<span class="lineNum">    1724 </span>                :<span class="lineCov">        105 : }</span>
<a name="1725"><span class="lineNum">    1725 </span>                :            : </a>
<span class="lineNum">    1726 </span>                :            : static int
<span class="lineNum">    1727 </span>                :<span class="lineCov">        105 : dmu_sync_late_arrival(zio_t *pio, objset_t *os, dmu_sync_cb_t *done, zgd_t *zgd,</span>
<span class="lineNum">    1728 </span>                :            :     zio_prop_t *zp, zbookmark_phys_t *zb)
<span class="lineNum">    1729 </span>                :            : {
<span class="lineNum">    1730 </span>                :            :         dmu_sync_arg_t *dsa;
<span class="lineNum">    1731 </span>                :            :         dmu_tx_t *tx;
<span class="lineNum">    1732 </span>                :            : 
<span class="lineNum">    1733 </span>                :<span class="lineCov">        105 :         tx = dmu_tx_create(os);</span>
<span class="lineNum">    1734 </span>                :<span class="lineCov">        105 :         dmu_tx_hold_space(tx, zgd-&gt;zgd_db-&gt;db_size);</span>
<span class="lineNum">    1735 </span>        [<span class="branchNoCov" title="Branch 1 was not taken"> - </span><span class="branchCov" title="Branch 2 was taken 105 times"> + </span>]:<span class="lineCov">        105 :         if (dmu_tx_assign(tx, TXG_WAIT) != 0) {</span>
<span class="lineNum">    1736 </span>                :<span class="lineNoCov">          0 :                 dmu_tx_abort(tx);</span>
<span class="lineNum">    1737 </span>                :            :                 /* Make zl_get_data do txg_waited_synced() */
<span class="lineNum">    1738 </span>                :<span class="lineNoCov">          0 :                 return (SET_ERROR(EIO));</span>
<span class="lineNum">    1739 </span>                :            :         }
<span class="lineNum">    1740 </span>                :            : 
<span class="lineNum">    1741 </span>                :<span class="lineCov">        105 :         dsa = kmem_alloc(sizeof (dmu_sync_arg_t), KM_SLEEP);</span>
<span class="lineNum">    1742 </span>                :<span class="lineCov">        105 :         dsa-&gt;dsa_dr = NULL;</span>
<span class="lineNum">    1743 </span>                :<span class="lineCov">        105 :         dsa-&gt;dsa_done = done;</span>
<span class="lineNum">    1744 </span>                :<span class="lineCov">        105 :         dsa-&gt;dsa_zgd = zgd;</span>
<span class="lineNum">    1745 </span>                :<span class="lineCov">        105 :         dsa-&gt;dsa_tx = tx;</span>
<span class="lineNum">    1746 </span>                :            : 
<span class="lineNum">    1747 </span>                :            :         /*
<span class="lineNum">    1748 </span>                :            :          * Since we are currently syncing this txg, it's nontrivial to
<span class="lineNum">    1749 </span>                :            :          * determine what BP to nopwrite against, so we disable nopwrite.
<span class="lineNum">    1750 </span>                :            :          *
<span class="lineNum">    1751 </span>                :            :          * When syncing, the db_blkptr is initially the BP of the previous
<span class="lineNum">    1752 </span>                :            :          * txg.  We can not nopwrite against it because it will be changed
<span class="lineNum">    1753 </span>                :            :          * (this is similar to the non-late-arrival case where the dbuf is
<span class="lineNum">    1754 </span>                :            :          * dirty in a future txg).
<span class="lineNum">    1755 </span>                :            :          *
<span class="lineNum">    1756 </span>                :            :          * Then dbuf_write_ready() sets bp_blkptr to the location we will write.
<span class="lineNum">    1757 </span>                :            :          * We can not nopwrite against it because although the BP will not
<span class="lineNum">    1758 </span>                :            :          * (typically) be changed, the data has not yet been persisted to this
<span class="lineNum">    1759 </span>                :            :          * location.
<span class="lineNum">    1760 </span>                :            :          *
<span class="lineNum">    1761 </span>                :            :          * Finally, when dbuf_write_done() is called, it is theoretically
<span class="lineNum">    1762 </span>                :            :          * possible to always nopwrite, because the data that was written in
<span class="lineNum">    1763 </span>                :            :          * this txg is the same data that we are trying to write.  However we
<span class="lineNum">    1764 </span>                :            :          * would need to check that this dbuf is not dirty in any future
<span class="lineNum">    1765 </span>                :            :          * txg's (as we do in the normal dmu_sync() path). For simplicity, we
<span class="lineNum">    1766 </span>                :            :          * don't nopwrite in this case.
<span class="lineNum">    1767 </span>                :            :          */
<span class="lineNum">    1768 </span>                :<span class="lineCov">        105 :         zp-&gt;zp_nopwrite = B_FALSE;</span>
<span class="lineNum">    1769 </span>                :            : 
<span class="lineNum">    1770 </span>                :<span class="lineCov">        105 :         zio_nowait(zio_write(pio, os-&gt;os_spa, dmu_tx_get_txg(tx), zgd-&gt;zgd_bp,</span>
<span class="lineNum">    1771 </span>                :<span class="lineCov">        105 :             abd_get_from_buf(zgd-&gt;zgd_db-&gt;db_data, zgd-&gt;zgd_db-&gt;db_size),</span>
<span class="lineNum">    1772 </span>                :<span class="lineCov">        105 :             zgd-&gt;zgd_db-&gt;db_size, zgd-&gt;zgd_db-&gt;db_size, zp,</span>
<span class="lineNum">    1773 </span>                :            :             dmu_sync_late_arrival_ready, NULL, NULL, dmu_sync_late_arrival_done,
<span class="lineNum">    1774 </span>                :            :             dsa, ZIO_PRIORITY_SYNC_WRITE, ZIO_FLAG_CANFAIL, zb));
<span class="lineNum">    1775 </span>                :            : 
<span class="lineNum">    1776 </span>                :<span class="lineCov">        105 :         return (0);</span>
<span class="lineNum">    1777 </span>                :            : }
<span class="lineNum">    1778 </span>                :            : 
<span class="lineNum">    1779 </span>                :            : /*
<span class="lineNum">    1780 </span>                :            :  * Intent log support: sync the block associated with db to disk.
<span class="lineNum">    1781 </span>                :            :  * N.B. and XXX: the caller is responsible for making sure that the
<span class="lineNum">    1782 </span>                :            :  * data isn't changing while dmu_sync() is writing it.
<span class="lineNum">    1783 </span>                :            :  *
<span class="lineNum">    1784 </span>                :            :  * Return values:
<span class="lineNum">    1785 </span>                :            :  *
<span class="lineNum">    1786 </span>                :            :  *      EEXIST: this txg has already been synced, so there's nothing to do.
<span class="lineNum">    1787 </span>                :            :  *              The caller should not log the write.
<span class="lineNum">    1788 </span>                :            :  *
<span class="lineNum">    1789 </span>                :            :  *      ENOENT: the block was dbuf_free_range()'d, so there's nothing to do.
<span class="lineNum">    1790 </span>                :            :  *              The caller should not log the write.
<span class="lineNum">    1791 </span>                :            :  *
<span class="lineNum">    1792 </span>                :            :  *      EALREADY: this block is already in the process of being synced.
<span class="lineNum">    1793 </span>                :            :  *              The caller should track its progress (somehow).
<span class="lineNum">    1794 </span>                :            :  *
<span class="lineNum">    1795 </span>                :            :  *      EIO: could not do the I/O.
<span class="lineNum">    1796 </span>                :            :  *              The caller should do a txg_wait_synced().
<span class="lineNum">    1797 </span>                :            :  *
<span class="lineNum">    1798 </span>                :            :  *      0: the I/O has been initiated.
<span class="lineNum">    1799 </span>                :            :  *              The caller should log this blkptr in the done callback.
<span class="lineNum">    1800 </span>                :            :  *              It is possible that the I/O will fail, in which case
<span class="lineNum">    1801 </span>                :            :  *              the error will be reported to the done callback and
<span class="lineNum">    1802 </span>                :            :  *              propagated to pio from zio_done().
<a name="1803"><span class="lineNum">    1803 </span>                :            :  */</a>
<span class="lineNum">    1804 </span>                :            : int
<span class="lineNum">    1805 </span>                :<span class="lineCov">        166 : dmu_sync(zio_t *pio, uint64_t txg, dmu_sync_cb_t *done, zgd_t *zgd)</span>
<span class="lineNum">    1806 </span>                :            : {
<span class="lineNum">    1807 </span>                :<span class="lineCov">        166 :         dmu_buf_impl_t *db = (dmu_buf_impl_t *)zgd-&gt;zgd_db;</span>
<span class="lineNum">    1808 </span>                :<span class="lineCov">        166 :         objset_t *os = db-&gt;db_objset;</span>
<span class="lineNum">    1809 </span>                :<span class="lineCov">        166 :         dsl_dataset_t *ds = os-&gt;os_dsl_dataset;</span>
<span class="lineNum">    1810 </span>                :            :         dbuf_dirty_record_t *dr;
<span class="lineNum">    1811 </span>                :            :         dmu_sync_arg_t *dsa;
<span class="lineNum">    1812 </span>                :            :         zbookmark_phys_t zb;
<span class="lineNum">    1813 </span>                :            :         zio_prop_t zp;
<span class="lineNum">    1814 </span>                :            :         dnode_t *dn;
<span class="lineNum">    1815 </span>                :            : 
<span class="lineNum">    1816 </span>        [<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 166 times"> + </span>]:<span class="lineCov">        166 :         ASSERT(pio != NULL);</span>
<span class="lineNum">    1817 </span>        [<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 166 times"> + </span>]:<span class="lineCov">        166 :         ASSERT(txg != 0);</span>
<span class="lineNum">    1818 </span>                :            : 
<span class="lineNum">    1819 </span>                :            :         /* dbuf is within the locked range */
<span class="lineNum">    1820 </span>        [<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 166 times"> + </span>]:<span class="lineCov">        166 :         ASSERT3U(db-&gt;db.db_offset, &gt;=, zgd-&gt;zgd_rl-&gt;r_off);</span>
<span class="lineNum">    1821 </span>        [<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 166 times"> + </span>]:<span class="lineCov">        166 :         ASSERT3U(db-&gt;db.db_offset + db-&gt;db.db_size, &lt;=,</span>
<span class="lineNum">    1822 </span>                :            :             zgd-&gt;zgd_rl-&gt;r_off + zgd-&gt;zgd_rl-&gt;r_len);
<span class="lineNum">    1823 </span>                :            : 
<span class="lineNum">    1824 </span>                :<span class="lineCov">        166 :         SET_BOOKMARK(&amp;zb, ds-&gt;ds_object,</span>
<span class="lineNum">    1825 </span>                :            :             db-&gt;db.db_object, db-&gt;db_level, db-&gt;db_blkid);
<span class="lineNum">    1826 </span>                :            : 
<span class="lineNum">    1827 </span>                :<span class="lineCov">        166 :         DB_DNODE_ENTER(db);</span>
<span class="lineNum">    1828 </span>                :<span class="lineCov">        166 :         dn = DB_DNODE(db);</span>
<span class="lineNum">    1829 </span>                :<span class="lineCov">        166 :         dmu_write_policy(os, dn, db-&gt;db_level, WP_DMU_SYNC, &amp;zp);</span>
<span class="lineNum">    1830 </span>                :<span class="lineCov">        166 :         DB_DNODE_EXIT(db);</span>
<span class="lineNum">    1831 </span>                :            : 
<span class="lineNum">    1832 </span>                :            :         /*
<span class="lineNum">    1833 </span>                :            :          * If we're frozen (running ziltest), we always need to generate a bp.
<span class="lineNum">    1834 </span>                :            :          */
<span class="lineNum">    1835 </span>        [<span class="branchCov" title="Branch 1 was taken 88 times"> + </span><span class="branchCov" title="Branch 2 was taken 78 times"> + </span>]:<span class="lineCov">        166 :         if (txg &gt; spa_freeze_txg(os-&gt;os_spa))</span>
<span class="lineNum">    1836 </span>                :<span class="lineCov">         88 :                 return (dmu_sync_late_arrival(pio, os, done, zgd, &amp;zp, &amp;zb));</span>
<span class="lineNum">    1837 </span>                :            : 
<span class="lineNum">    1838 </span>                :            :         /*
<span class="lineNum">    1839 </span>                :            :          * Grabbing db_mtx now provides a barrier between dbuf_sync_leaf()
<span class="lineNum">    1840 </span>                :            :          * and us.  If we determine that this txg is not yet syncing,
<span class="lineNum">    1841 </span>                :            :          * but it begins to sync a moment later, that's OK because the
<span class="lineNum">    1842 </span>                :            :          * sync thread will block in dbuf_sync_leaf() until we drop db_mtx.
<span class="lineNum">    1843 </span>                :            :          */
<span class="lineNum">    1844 </span>                :<span class="lineCov">         78 :         mutex_enter(&amp;db-&gt;db_mtx);</span>
<span class="lineNum">    1845 </span>                :            : 
<span class="lineNum">    1846 </span>        [<span class="branchCov" title="Branch 1 was taken 1 time"> + </span><span class="branchCov" title="Branch 2 was taken 77 times"> + </span>]:<span class="lineCov">         78 :         if (txg &lt;= spa_last_synced_txg(os-&gt;os_spa)) {</span>
<span class="lineNum">    1847 </span>                :            :                 /*
<span class="lineNum">    1848 </span>                :            :                  * This txg has already synced.  There's nothing to do.
<span class="lineNum">    1849 </span>                :            :                  */
<span class="lineNum">    1850 </span>                :<span class="lineCov">          1 :                 mutex_exit(&amp;db-&gt;db_mtx);</span>
<span class="lineNum">    1851 </span>                :<span class="lineCov">          1 :                 return (SET_ERROR(EEXIST));</span>
<span class="lineNum">    1852 </span>                :            :         }
<span class="lineNum">    1853 </span>                :            : 
<span class="lineNum">    1854 </span>        [<span class="branchCov" title="Branch 1 was taken 17 times"> + </span><span class="branchCov" title="Branch 2 was taken 60 times"> + </span>]:<span class="lineCov">         77 :         if (txg &lt;= spa_syncing_txg(os-&gt;os_spa)) {</span>
<span class="lineNum">    1855 </span>                :            :                 /*
<span class="lineNum">    1856 </span>                :            :                  * This txg is currently syncing, so we can't mess with
<span class="lineNum">    1857 </span>                :            :                  * the dirty record anymore; just write a new log block.
<span class="lineNum">    1858 </span>                :            :                  */
<span class="lineNum">    1859 </span>                :<span class="lineCov">         17 :                 mutex_exit(&amp;db-&gt;db_mtx);</span>
<span class="lineNum">    1860 </span>                :<span class="lineCov">         17 :                 return (dmu_sync_late_arrival(pio, os, done, zgd, &amp;zp, &amp;zb));</span>
<span class="lineNum">    1861 </span>                :            :         }
<span class="lineNum">    1862 </span>                :            : 
<span class="lineNum">    1863 </span>                :<span class="lineCov">         60 :         dr = db-&gt;db_last_dirty;</span>
<span class="lineNum">    1864 </span>[<span class="branchCov" title="Branch 0 was taken 56 times"> + </span><span class="branchCov" title="Branch 1 was taken 4 times"> + </span>][<span class="branchNoCov" title="Branch 2 was not taken"> - </span><span class="branchCov" title="Branch 3 was taken 56 times"> + </span>]:<span class="lineCov">         60 :         while (dr &amp;&amp; dr-&gt;dr_txg != txg)</span>
<span class="lineNum">    1865 </span>                :<span class="lineNoCov">          0 :                 dr = dr-&gt;dr_next;</span>
<span class="lineNum">    1866 </span>                :            : 
<span class="lineNum">    1867 </span>        [<span class="branchCov" title="Branch 0 was taken 4 times"> + </span><span class="branchCov" title="Branch 1 was taken 56 times"> + </span>]:<span class="lineCov">         60 :         if (dr == NULL) {</span>
<span class="lineNum">    1868 </span>                :            :                 /*
<span class="lineNum">    1869 </span>                :            :                  * There's no dr for this dbuf, so it must have been freed.
<span class="lineNum">    1870 </span>                :            :                  * There's no need to log writes to freed blocks, so we're done.
<span class="lineNum">    1871 </span>                :            :                  */
<span class="lineNum">    1872 </span>                :<span class="lineCov">          4 :                 mutex_exit(&amp;db-&gt;db_mtx);</span>
<span class="lineNum">    1873 </span>                :<span class="lineCov">          4 :                 return (SET_ERROR(ENOENT));</span>
<span class="lineNum">    1874 </span>                :            :         }
<span class="lineNum">    1875 </span>                :            : 
<span class="lineNum">    1876 </span>[<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 56 times"> + </span>][<span class="branchNoExec" title="Branch 2 was not executed"> # </span><span class="branchNoExec" title="Branch 3 was not executed"> # </span>]:<span class="lineCov">         56 :         ASSERT(dr-&gt;dr_next == NULL || dr-&gt;dr_next-&gt;dr_txg &lt; txg);</span>
<span class="lineNum">    1877 </span>                :            : 
<span class="lineNum">    1878 </span>        [<span class="branchCov" title="Branch 0 was taken 51 times"> + </span><span class="branchCov" title="Branch 1 was taken 5 times"> + </span>]:<span class="lineCov">         56 :         if (db-&gt;db_blkptr != NULL) {</span>
<span class="lineNum">    1879 </span>                :            :                 /*
<span class="lineNum">    1880 </span>                :            :                  * We need to fill in zgd_bp with the current blkptr so that
<span class="lineNum">    1881 </span>                :            :                  * the nopwrite code can check if we're writing the same
<span class="lineNum">    1882 </span>                :            :                  * data that's already on disk.  We can only nopwrite if we
<span class="lineNum">    1883 </span>                :            :                  * are sure that after making the copy, db_blkptr will not
<span class="lineNum">    1884 </span>                :            :                  * change until our i/o completes.  We ensure this by
<span class="lineNum">    1885 </span>                :            :                  * holding the db_mtx, and only allowing nopwrite if the
<span class="lineNum">    1886 </span>                :            :                  * block is not already dirty (see below).  This is verified
<span class="lineNum">    1887 </span>                :            :                  * by dmu_sync_done(), which VERIFYs that the db_blkptr has
<span class="lineNum">    1888 </span>                :            :                  * not changed.
<span class="lineNum">    1889 </span>                :            :                  */
<span class="lineNum">    1890 </span>                :<span class="lineCov">         51 :                 *zgd-&gt;zgd_bp = *db-&gt;db_blkptr;</span>
<span class="lineNum">    1891 </span>                :            :         }
<span class="lineNum">    1892 </span>                :            : 
<span class="lineNum">    1893 </span>                :            :         /*
<span class="lineNum">    1894 </span>                :            :          * Assume the on-disk data is X, the current syncing data (in
<span class="lineNum">    1895 </span>                :            :          * txg - 1) is Y, and the current in-memory data is Z (currently
<span class="lineNum">    1896 </span>                :            :          * in dmu_sync).
<span class="lineNum">    1897 </span>                :            :          *
<span class="lineNum">    1898 </span>                :            :          * We usually want to perform a nopwrite if X and Z are the
<span class="lineNum">    1899 </span>                :            :          * same.  However, if Y is different (i.e. the BP is going to
<span class="lineNum">    1900 </span>                :            :          * change before this write takes effect), then a nopwrite will
<span class="lineNum">    1901 </span>                :            :          * be incorrect - we would override with X, which could have
<span class="lineNum">    1902 </span>                :            :          * been freed when Y was written.
<span class="lineNum">    1903 </span>                :            :          *
<span class="lineNum">    1904 </span>                :            :          * (Note that this is not a concern when we are nop-writing from
<span class="lineNum">    1905 </span>                :            :          * syncing context, because X and Y must be identical, because
<span class="lineNum">    1906 </span>                :            :          * all previous txgs have been synced.)
<span class="lineNum">    1907 </span>                :            :          *
<span class="lineNum">    1908 </span>                :            :          * Therefore, we disable nopwrite if the current BP could change
<span class="lineNum">    1909 </span>                :            :          * before this TXG.  There are two ways it could change: by
<span class="lineNum">    1910 </span>                :            :          * being dirty (dr_next is non-NULL), or by being freed
<span class="lineNum">    1911 </span>                :            :          * (dnode_block_freed()).  This behavior is verified by
<span class="lineNum">    1912 </span>                :            :          * zio_done(), which VERIFYs that the override BP is identical
<span class="lineNum">    1913 </span>                :            :          * to the on-disk BP.
<span class="lineNum">    1914 </span>                :            :          */
<span class="lineNum">    1915 </span>                :<span class="lineCov">         56 :         DB_DNODE_ENTER(db);</span>
<span class="lineNum">    1916 </span>                :<span class="lineCov">         56 :         dn = DB_DNODE(db);</span>
<span class="lineNum">    1917 </span>[<span class="branchCov" title="Branch 0 was taken 56 times"> + </span><span class="branchNoCov" title="Branch 1 was not taken"> - </span>][<span class="branchNoCov" title="Branch 3 was not taken"> - </span><span class="branchCov" title="Branch 4 was taken 56 times"> + </span>]:<span class="lineCov">         56 :         if (dr-&gt;dr_next != NULL || dnode_block_freed(dn, db-&gt;db_blkid))</span>
<span class="lineNum">    1918 </span>                :<span class="lineNoCov">          0 :                 zp.zp_nopwrite = B_FALSE;</span>
<span class="lineNum">    1919 </span>                :<span class="lineCov">         56 :         DB_DNODE_EXIT(db);</span>
<span class="lineNum">    1920 </span>                :            : 
<span class="lineNum">    1921 </span>        [<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 56 times"> + </span>]:<span class="lineCov">         56 :         ASSERT(dr-&gt;dr_txg == txg);</span>
<span class="lineNum">    1922 </span>        [<span class="branchCov" title="Branch 0 was taken 20 times"> + </span><span class="branchCov" title="Branch 1 was taken 36 times"> + </span>]:<span class="lineCov">         56 :         if (dr-&gt;dt.dl.dr_override_state == DR_IN_DMU_SYNC ||</span>
<span class="lineNum">    1923 </span>                :            :             dr-&gt;dt.dl.dr_override_state == DR_OVERRIDDEN) {
<span class="lineNum">    1924 </span>                :            :                 /*
<span class="lineNum">    1925 </span>                :            :                  * We have already issued a sync write for this buffer,
<span class="lineNum">    1926 </span>                :            :                  * or this buffer has already been synced.  It could not
<span class="lineNum">    1927 </span>                :            :                  * have been dirtied since, or we would have cleared the state.
<span class="lineNum">    1928 </span>                :            :                  */
<span class="lineNum">    1929 </span>                :<span class="lineCov">         20 :                 mutex_exit(&amp;db-&gt;db_mtx);</span>
<span class="lineNum">    1930 </span>                :<span class="lineCov">         20 :                 return (SET_ERROR(EALREADY));</span>
<span class="lineNum">    1931 </span>                :            :         }
<span class="lineNum">    1932 </span>                :            : 
<span class="lineNum">    1933 </span>        [<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 36 times"> + </span>]:<span class="lineCov">         36 :         ASSERT(dr-&gt;dt.dl.dr_override_state == DR_NOT_OVERRIDDEN);</span>
<span class="lineNum">    1934 </span>                :<span class="lineCov">         36 :         dr-&gt;dt.dl.dr_override_state = DR_IN_DMU_SYNC;</span>
<span class="lineNum">    1935 </span>                :<span class="lineCov">         36 :         mutex_exit(&amp;db-&gt;db_mtx);</span>
<span class="lineNum">    1936 </span>                :            : 
<span class="lineNum">    1937 </span>                :<span class="lineCov">         36 :         dsa = kmem_alloc(sizeof (dmu_sync_arg_t), KM_SLEEP);</span>
<span class="lineNum">    1938 </span>                :<span class="lineCov">         36 :         dsa-&gt;dsa_dr = dr;</span>
<span class="lineNum">    1939 </span>                :<span class="lineCov">         36 :         dsa-&gt;dsa_done = done;</span>
<span class="lineNum">    1940 </span>                :<span class="lineCov">         36 :         dsa-&gt;dsa_zgd = zgd;</span>
<span class="lineNum">    1941 </span>                :<span class="lineCov">         36 :         dsa-&gt;dsa_tx = NULL;</span>
<span class="lineNum">    1942 </span>                :            : 
<span class="lineNum">    1943 </span>                :<span class="lineCov">         36 :         zio_nowait(arc_write(pio, os-&gt;os_spa, txg,</span>
<span class="lineNum">    1944 </span>[<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 36 times"> + </span>][<span class="branchNoExec" title="Branch 3 was not executed"> # </span><span class="branchNoExec" title="Branch 4 was not executed"> # </span>]:<span class="lineCov">         36 :             zgd-&gt;zgd_bp, dr-&gt;dt.dl.dr_data, DBUF_IS_L2CACHEABLE(db),</span>
<span class="lineNum">         </span>        [<span class="branchNoExec" title="Branch 5 was not executed"> # </span><span class="branchNoExec" title="Branch 6 was not executed"> # </span>]
<span class="lineNum">    1945 </span>                :            :             &amp;zp, dmu_sync_ready, NULL, NULL, dmu_sync_done, dsa,
<span class="lineNum">    1946 </span>                :            :             ZIO_PRIORITY_SYNC_WRITE, ZIO_FLAG_CANFAIL, &amp;zb));
<span class="lineNum">    1947 </span>                :            : 
<span class="lineNum">    1948 </span>                :<span class="lineCov">         36 :         return (0);</span>
<span class="lineNum">    1949 </span>                :            : }
<a name="1950"><span class="lineNum">    1950 </span>                :            : </a>
<span class="lineNum">    1951 </span>                :            : int
<span class="lineNum">    1952 </span>                :<span class="lineNoCov">          0 : dmu_object_set_nlevels(objset_t *os, uint64_t object, int nlevels, dmu_tx_t *tx)</span>
<span class="lineNum">    1953 </span>                :            : {
<span class="lineNum">    1954 </span>                :            :         dnode_t *dn;
<span class="lineNum">    1955 </span>                :            :         int err;
<span class="lineNum">    1956 </span>                :            : 
<span class="lineNum">    1957 </span>                :<span class="lineNoCov">          0 :         err = dnode_hold(os, object, FTAG, &amp;dn);</span>
<span class="lineNum">    1958 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :         if (err)</span>
<span class="lineNum">    1959 </span>                :            :                 return (err);
<span class="lineNum">    1960 </span>                :<span class="lineNoCov">          0 :         err = dnode_set_nlevels(dn, nlevels, tx);</span>
<span class="lineNum">    1961 </span>                :<span class="lineNoCov">          0 :         dnode_rele(dn, FTAG);</span>
<span class="lineNum">    1962 </span>                :<span class="lineNoCov">          0 :         return (err);</span>
<span class="lineNum">    1963 </span>                :            : }
<a name="1964"><span class="lineNum">    1964 </span>                :            : </a>
<span class="lineNum">    1965 </span>                :            : int
<span class="lineNum">    1966 </span>                :<span class="lineCov">      10358 : dmu_object_set_blocksize(objset_t *os, uint64_t object, uint64_t size, int ibs,</span>
<span class="lineNum">    1967 </span>                :            :     dmu_tx_t *tx)
<span class="lineNum">    1968 </span>                :            : {
<span class="lineNum">    1969 </span>                :            :         dnode_t *dn;
<span class="lineNum">    1970 </span>                :            :         int err;
<span class="lineNum">    1971 </span>                :            : 
<span class="lineNum">    1972 </span>                :<span class="lineCov">      10358 :         err = dnode_hold(os, object, FTAG, &amp;dn);</span>
<span class="lineNum">    1973 </span>        [<span class="branchCov" title="Branch 0 was taken 10359 times"> + </span><span class="branchNoCov" title="Branch 1 was not taken"> - </span>]:<span class="lineCov">      10359 :         if (err)</span>
<span class="lineNum">    1974 </span>                :            :                 return (err);
<span class="lineNum">    1975 </span>                :<span class="lineCov">      10359 :         err = dnode_set_blksz(dn, size, ibs, tx);</span>
<span class="lineNum">    1976 </span>                :<span class="lineCov">      10359 :         dnode_rele(dn, FTAG);</span>
<span class="lineNum">    1977 </span>                :<span class="lineCov">      10359 :         return (err);</span>
<span class="lineNum">    1978 </span>                :            : }
<a name="1979"><span class="lineNum">    1979 </span>                :            : </a>
<span class="lineNum">    1980 </span>                :            : void
<span class="lineNum">    1981 </span>                :<span class="lineCov">        256 : dmu_object_set_checksum(objset_t *os, uint64_t object, uint8_t checksum,</span>
<span class="lineNum">    1982 </span>                :            :     dmu_tx_t *tx)
<span class="lineNum">    1983 </span>                :            : {
<span class="lineNum">    1984 </span>                :            :         dnode_t *dn;
<span class="lineNum">    1985 </span>                :            : 
<span class="lineNum">    1986 </span>                :            :         /*
<span class="lineNum">    1987 </span>                :            :          * Send streams include each object's checksum function.  This
<span class="lineNum">    1988 </span>                :            :          * check ensures that the receiving system can understand the
<span class="lineNum">    1989 </span>                :            :          * checksum function transmitted.
<span class="lineNum">    1990 </span>                :            :          */
<span class="lineNum">    1991 </span>        [<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 256 times"> + </span>]:<span class="lineCov">        256 :         ASSERT3U(checksum, &lt;, ZIO_CHECKSUM_LEGACY_FUNCTIONS);</span>
<span class="lineNum">    1992 </span>                :            : 
<span class="lineNum">    1993 </span>        [<span class="branchNoCov" title="Branch 1 was not taken"> - </span><span class="branchCov" title="Branch 2 was taken 256 times"> + </span>]:<span class="lineCov">        256 :         VERIFY0(dnode_hold(os, object, FTAG, &amp;dn));</span>
<span class="lineNum">    1994 </span>        [<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 256 times"> + </span>]:<span class="lineCov">        256 :         ASSERT3U(checksum, &lt;, ZIO_CHECKSUM_FUNCTIONS);</span>
<span class="lineNum">    1995 </span>                :<span class="lineCov">        256 :         dn-&gt;dn_checksum = checksum;</span>
<span class="lineNum">    1996 </span>                :<span class="lineCov">        256 :         dnode_setdirty(dn, tx);</span>
<span class="lineNum">    1997 </span>                :<span class="lineCov">        256 :         dnode_rele(dn, FTAG);</span>
<span class="lineNum">    1998 </span>                :<span class="lineCov">        256 : }</span>
<a name="1999"><span class="lineNum">    1999 </span>                :            : </a>
<span class="lineNum">    2000 </span>                :            : void
<span class="lineNum">    2001 </span>                :<span class="lineCov">        309 : dmu_object_set_compress(objset_t *os, uint64_t object, uint8_t compress,</span>
<span class="lineNum">    2002 </span>                :            :     dmu_tx_t *tx)
<span class="lineNum">    2003 </span>                :            : {
<span class="lineNum">    2004 </span>                :            :         dnode_t *dn;
<span class="lineNum">    2005 </span>                :            : 
<span class="lineNum">    2006 </span>                :            :         /*
<span class="lineNum">    2007 </span>                :            :          * Send streams include each object's compression function.  This
<span class="lineNum">    2008 </span>                :            :          * check ensures that the receiving system can understand the
<span class="lineNum">    2009 </span>                :            :          * compression function transmitted.
<span class="lineNum">    2010 </span>                :            :          */
<span class="lineNum">    2011 </span>        [<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 309 times"> + </span>]:<span class="lineCov">        309 :         ASSERT3U(compress, &lt;, ZIO_COMPRESS_LEGACY_FUNCTIONS);</span>
<span class="lineNum">    2012 </span>                :            : 
<span class="lineNum">    2013 </span>        [<span class="branchNoCov" title="Branch 1 was not taken"> - </span><span class="branchCov" title="Branch 2 was taken 309 times"> + </span>]:<span class="lineCov">        309 :         VERIFY0(dnode_hold(os, object, FTAG, &amp;dn));</span>
<span class="lineNum">    2014 </span>                :<span class="lineCov">        309 :         dn-&gt;dn_compress = compress;</span>
<span class="lineNum">    2015 </span>                :<span class="lineCov">        309 :         dnode_setdirty(dn, tx);</span>
<span class="lineNum">    2016 </span>                :<span class="lineCov">        309 :         dnode_rele(dn, FTAG);</span>
<span class="lineNum">    2017 </span>                :<span class="lineCov">        309 : }</span>
<span class="lineNum">    2018 </span>                :            : 
<span class="lineNum">    2019 </span>                :            : /*
<span class="lineNum">    2020 </span>                :            :  * Dirty an object and set the dirty record's raw flag. This is used
<span class="lineNum">    2021 </span>                :            :  * when writing raw data to an object that will not effect the
<span class="lineNum">    2022 </span>                :            :  * encryption parameters, specifically during raw receives.
<a name="2023"><span class="lineNum">    2023 </span>                :            :  */</a>
<span class="lineNum">    2024 </span>                :            : int
<span class="lineNum">    2025 </span>                :<span class="lineNoCov">          0 : dmu_object_dirty_raw(objset_t *os, uint64_t object, dmu_tx_t *tx)</span>
<span class="lineNum">    2026 </span>                :            : {
<span class="lineNum">    2027 </span>                :            :         dnode_t *dn;
<span class="lineNum">    2028 </span>                :            :         int err;
<span class="lineNum">    2029 </span>                :            : 
<span class="lineNum">    2030 </span>                :<span class="lineNoCov">          0 :         err = dnode_hold(os, object, FTAG, &amp;dn);</span>
<span class="lineNum">    2031 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :         if (err)</span>
<span class="lineNum">    2032 </span>                :            :                 return (err);
<span class="lineNum">    2033 </span>                :<span class="lineNoCov">          0 :         dmu_buf_will_change_crypt_params((dmu_buf_t *)dn-&gt;dn_dbuf, tx);</span>
<span class="lineNum">    2034 </span>                :<span class="lineNoCov">          0 :         dnode_rele(dn, FTAG);</span>
<span class="lineNum">    2035 </span>                :<span class="lineNoCov">          0 :         return (err);</span>
<span class="lineNum">    2036 </span>                :            : }
<span class="lineNum">    2037 </span>                :            : 
<span class="lineNum">    2038 </span>                :            : int zfs_mdcomp_disable = 0;
<span class="lineNum">    2039 </span>                :            : 
<span class="lineNum">    2040 </span>                :            : /*
<span class="lineNum">    2041 </span>                :            :  * When the &quot;redundant_metadata&quot; property is set to &quot;most&quot;, only indirect
<span class="lineNum">    2042 </span>                :            :  * blocks of this level and higher will have an additional ditto block.
<span class="lineNum">    2043 </span>                :            :  */
<span class="lineNum">    2044 </span>                :            : int zfs_redundant_metadata_most_ditto_level = 2;
<a name="2045"><span class="lineNum">    2045 </span>                :            : </a>
<span class="lineNum">    2046 </span>                :            : void
<span class="lineNum">    2047 </span>                :<span class="lineCov">     727832 : dmu_write_policy(objset_t *os, dnode_t *dn, int level, int wp, zio_prop_t *zp)</span>
<span class="lineNum">    2048 </span>                :            : {
<span class="lineNum">    2049 </span>        [<span class="branchCov" title="Branch 0 was taken 658584 times"> + </span><span class="branchCov" title="Branch 1 was taken 69248 times"> + </span>]:<span class="lineCov">     727832 :         dmu_object_type_t type = dn ? dn-&gt;dn_type : DMU_OT_OBJSET;</span>
<span class="lineNum">    2050 </span>[<span class="branchCov" title="Branch 0 was taken 417513 times"> + </span><span class="branchCov" title="Branch 1 was taken 310319 times"> + </span>][<span class="branchCov" title="Branch 2 was taken 3959 times"> + </span><span class="branchCov" title="Branch 3 was taken 413554 times"> + </span>]:<span class="lineCov">     727832 :         boolean_t ismd = (level &gt; 0 || DMU_OT_IS_METADATA(type) ||</span>
<span class="lineNum">         </span>[<span class="branchNoCov" title="Branch 4 was not taken"> - </span><span class="branchCov" title="Branch 5 was taken 3959 times"> + </span>][<span class="branchCov" title="Branch 6 was taken 54079 times"> + </span><span class="branchCov" title="Branch 7 was taken 359475 times"> + </span>]
<span class="lineNum">         </span>        [<span class="branchCov" title="Branch 8 was taken 54079 times"> + </span><span class="branchNoCov" title="Branch 9 was not taken"> - </span>]
<span class="lineNum">    2051 </span>                :<span class="lineCov">      54079 :             (wp &amp; WP_SPILL));</span>
<span class="lineNum">    2052 </span>                :<span class="lineCov">     727832 :         enum zio_checksum checksum = os-&gt;os_checksum;</span>
<span class="lineNum">    2053 </span>                :<span class="lineCov">     727832 :         enum zio_compress compress = os-&gt;os_compress;</span>
<span class="lineNum">    2054 </span>                :<span class="lineCov">     727832 :         enum zio_checksum dedup_checksum = os-&gt;os_dedup_checksum;</span>
<span class="lineNum">    2055 </span>                :<span class="lineCov">     727832 :         boolean_t dedup = B_FALSE;</span>
<span class="lineNum">    2056 </span>                :<span class="lineCov">     727832 :         boolean_t nopwrite = B_FALSE;</span>
<span class="lineNum">    2057 </span>                :<span class="lineCov">     727832 :         boolean_t dedup_verify = os-&gt;os_dedup_verify;</span>
<span class="lineNum">    2058 </span>                :<span class="lineCov">     727832 :         boolean_t encrypt = B_FALSE;</span>
<span class="lineNum">    2059 </span>                :<span class="lineCov">     727832 :         int copies = os-&gt;os_copies;</span>
<span class="lineNum">    2060 </span>                :            : 
<span class="lineNum">    2061 </span>                :            :         /*
<span class="lineNum">    2062 </span>                :            :          * We maintain different write policies for each of the following
<span class="lineNum">    2063 </span>                :            :          * types of data:
<span class="lineNum">    2064 </span>                :            :          *       1. metadata
<span class="lineNum">    2065 </span>                :            :          *       2. preallocated blocks (i.e. level-0 blocks of a dump device)
<span class="lineNum">    2066 </span>                :            :          *       3. all other level 0 blocks
<span class="lineNum">    2067 </span>                :            :          */
<span class="lineNum">    2068 </span>        [<span class="branchCov" title="Branch 0 was taken 673753 times"> + </span><span class="branchCov" title="Branch 1 was taken 54079 times"> + </span>]:<span class="lineCov">     727832 :         if (ismd) {</span>
<span class="lineNum">    2069 </span>        [<span class="branchCov" title="Branch 0 was taken 673749 times"> + </span><span class="branchCov" title="Branch 1 was taken 4 times"> + </span>]:<span class="lineCov">     673753 :                 if (zfs_mdcomp_disable) {</span>
<span class="lineNum">    2070 </span>                :            :                         compress = ZIO_COMPRESS_EMPTY;
<span class="lineNum">    2071 </span>                :            :                 } else {
<span class="lineNum">    2072 </span>                :            :                         /*
<span class="lineNum">    2073 </span>                :            :                          * XXX -- we should design a compression algorithm
<span class="lineNum">    2074 </span>                :            :                          * that specializes in arrays of bps.
<span class="lineNum">    2075 </span>                :            :                          */
<span class="lineNum">    2076 </span>                :<span class="lineCov">     673749 :                         compress = zio_compress_select(os-&gt;os_spa,</span>
<span class="lineNum">    2077 </span>                :            :                             ZIO_COMPRESS_ON, ZIO_COMPRESS_ON);
<span class="lineNum">    2078 </span>                :            :                 }
<span class="lineNum">    2079 </span>                :            : 
<span class="lineNum">    2080 </span>                :            :                 /*
<span class="lineNum">    2081 </span>                :            :                  * Metadata always gets checksummed.  If the data
<span class="lineNum">    2082 </span>                :            :                  * checksum is multi-bit correctable, and it's not a
<span class="lineNum">    2083 </span>                :            :                  * ZBT-style checksum, then it's suitable for metadata
<span class="lineNum">    2084 </span>                :            :                  * as well.  Otherwise, the metadata checksum defaults
<span class="lineNum">    2085 </span>                :            :                  * to fletcher4.
<span class="lineNum">    2086 </span>                :            :                  */
<span class="lineNum">    2087 </span>        [<span class="branchCov" title="Branch 0 was taken 665823 times"> + </span><span class="branchCov" title="Branch 1 was taken 7906 times"> + </span>]:<span class="lineCov">     673729 :                 if (!(zio_checksum_table[checksum].ci_flags &amp;</span>
<span class="lineNum">    2088 </span>        [<span class="branchCov" title="Branch 0 was taken 2 times"> + </span><span class="branchCov" title="Branch 1 was taken 665821 times"> + </span>]:<span class="lineCov">     665823 :                     ZCHECKSUM_FLAG_METADATA) ||</span>
<span class="lineNum">    2089 </span>                :<span class="lineCov">     665823 :                     (zio_checksum_table[checksum].ci_flags &amp;</span>
<span class="lineNum">    2090 </span>                :            :                     ZCHECKSUM_FLAG_EMBEDDED))
<span class="lineNum">    2091 </span>                :<span class="lineCov">       7908 :                         checksum = ZIO_CHECKSUM_FLETCHER_4;</span>
<span class="lineNum">    2092 </span>                :            : 
<span class="lineNum">    2093 </span>[<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 673729 times"> + </span>][<span class="branchNoExec" title="Branch 2 was not executed"> # </span><span class="branchNoExec" title="Branch 3 was not executed"> # </span>]:<span class="lineCov">     673729 :                 if (os-&gt;os_redundant_metadata == ZFS_REDUNDANT_METADATA_ALL ||</span>
<span class="lineNum">         </span>        [<span class="branchNoExec" title="Branch 4 was not executed"> # </span><span class="branchNoExec" title="Branch 5 was not executed"> # </span>]
<span class="lineNum">    2094 </span>                :            :                     (os-&gt;os_redundant_metadata ==
<span class="lineNum">    2095 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :                     ZFS_REDUNDANT_METADATA_MOST &amp;&amp;</span>
<span class="lineNum">    2096 </span>[<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>][<span class="branchNoExec" title="Branch 2 was not executed"> # </span><span class="branchNoExec" title="Branch 3 was not executed"> # </span>]:<span class="lineNoCov">          0 :                     (level &gt;= zfs_redundant_metadata_most_ditto_level ||</span>
<span class="lineNum">    2097 </span>           [<span class="branchNoCov" title="Branch 0 was not taken"> - </span>]:<span class="lineNoCov">          0 :                     DMU_OT_IS_METADATA(type) || (wp &amp; WP_SPILL))))</span>
<span class="lineNum">    2098 </span>                :<span class="lineCov">     673744 :                         copies++;</span>
<span class="lineNum">    2099 </span>        [<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 54079 times"> + </span>]:<span class="lineCov">      54079 :         } else if (wp &amp; WP_NOFILL) {</span>
<span class="lineNum">    2100 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :                 ASSERT(level == 0);</span>
<span class="lineNum">    2101 </span>                :            : 
<span class="lineNum">    2102 </span>                :            :                 /*
<span class="lineNum">    2103 </span>                :            :                  * If we're writing preallocated blocks, we aren't actually
<span class="lineNum">    2104 </span>                :            :                  * writing them so don't set any policy properties.  These
<span class="lineNum">    2105 </span>                :            :                  * blocks are currently only used by an external subsystem
<span class="lineNum">    2106 </span>                :            :                  * outside of zfs (i.e. dump) and not written by the zio
<span class="lineNum">    2107 </span>                :            :                  * pipeline.
<span class="lineNum">    2108 </span>                :            :                  */
<span class="lineNum">    2109 </span>                :            :                 compress = ZIO_COMPRESS_OFF;
<span class="lineNum">    2110 </span>                :            :                 checksum = ZIO_CHECKSUM_OFF;
<span class="lineNum">    2111 </span>                :            :         } else {
<span class="lineNum">    2112 </span>                :<span class="lineCov">      54079 :                 compress = zio_compress_select(os-&gt;os_spa, dn-&gt;dn_compress,</span>
<span class="lineNum">    2113 </span>                :            :                     compress);
<span class="lineNum">    2114 </span>                :            : 
<span class="lineNum">    2115 </span>                :<span class="lineCov">      54078 :                 checksum = (dedup_checksum == ZIO_CHECKSUM_OFF) ?</span>
<span class="lineNum">    2116 </span>        [<span class="branchCov" title="Branch 0 was taken 36237 times"> + </span><span class="branchCov" title="Branch 1 was taken 17842 times"> + </span>]:<span class="lineCov">      54079 :                     zio_checksum_select(dn-&gt;dn_checksum, checksum) :</span>
<span class="lineNum">    2117 </span>                :            :                     dedup_checksum;
<span class="lineNum">    2118 </span>                :            : 
<span class="lineNum">    2119 </span>                :            :                 /*
<span class="lineNum">    2120 </span>                :            :                  * Determine dedup setting.  If we are in dmu_sync(),
<span class="lineNum">    2121 </span>                :            :                  * we won't actually dedup now because that's all
<span class="lineNum">    2122 </span>                :            :                  * done in syncing context; but we do want to use the
<span class="lineNum">    2123 </span>                :            :                  * dedup checkum.  If the checksum is not strong
<span class="lineNum">    2124 </span>                :            :                  * enough to ensure unique signatures, force
<span class="lineNum">    2125 </span>                :            :                  * dedup_verify.
<span class="lineNum">    2126 </span>                :            :                  */
<span class="lineNum">    2127 </span>        [<span class="branchCov" title="Branch 0 was taken 17842 times"> + </span><span class="branchCov" title="Branch 1 was taken 36236 times"> + </span>]:<span class="lineCov">      54078 :                 if (dedup_checksum != ZIO_CHECKSUM_OFF) {</span>
<span class="lineNum">    2128 </span>                :<span class="lineCov">      17842 :                         dedup = (wp &amp; WP_DMU_SYNC) ? B_FALSE : B_TRUE;</span>
<span class="lineNum">    2129 </span>        [<span class="branchCov" title="Branch 0 was taken 741 times"> + </span><span class="branchCov" title="Branch 1 was taken 17101 times"> + </span>]:<span class="lineCov">      17842 :                         if (!(zio_checksum_table[checksum].ci_flags &amp;</span>
<span class="lineNum">    2130 </span>                :            :                             ZCHECKSUM_FLAG_DEDUP))
<span class="lineNum">    2131 </span>                :<span class="lineCov">        741 :                                 dedup_verify = B_TRUE;</span>
<span class="lineNum">    2132 </span>                :            :                 }
<span class="lineNum">    2133 </span>                :            : 
<span class="lineNum">    2134 </span>                :            :                 /*
<span class="lineNum">    2135 </span>                :            :                  * Enable nopwrite if we have secure enough checksum
<span class="lineNum">    2136 </span>                :            :                  * algorithm (see comment in zio_nop_write) and
<span class="lineNum">    2137 </span>                :            :                  * compression is enabled.  We don't enable nopwrite if
<span class="lineNum">    2138 </span>                :            :                  * dedup is enabled as the two features are mutually
<span class="lineNum">    2139 </span>                :            :                  * exclusive.
<span class="lineNum">    2140 </span>                :            :                  */
<span class="lineNum">    2141 </span>        [<span class="branchCov" title="Branch 0 was taken 17765 times"> + </span><span class="branchCov" title="Branch 1 was taken 18490 times"> + </span>]:<span class="lineCov">      90333 :                 nopwrite = (!dedup &amp;&amp; (zio_checksum_table[checksum].ci_flags &amp;</span>
<span class="lineNum">    2142 </span>        [<span class="branchCov" title="Branch 0 was taken 16866 times"> + </span><span class="branchCov" title="Branch 1 was taken 899 times"> + </span>]:<span class="lineCov">      17765 :                     ZCHECKSUM_FLAG_NOPWRITE) &amp;&amp;</span>
<span class="lineNum">    2143 </span>[<span class="branchCov" title="Branch 0 was taken 36255 times"> + </span><span class="branchCov" title="Branch 1 was taken 17823 times"> + </span>][<span class="branchCov" title="Branch 2 was taken 1 time"> + </span><span class="branchCov" title="Branch 3 was taken 16865 times"> + </span>]:<span class="lineCov">      90333 :                     compress != ZIO_COMPRESS_OFF &amp;&amp; zfs_nopwrite_enabled);</span>
<span class="lineNum">    2144 </span>                :            :         }
<span class="lineNum">    2145 </span>                :            : 
<span class="lineNum">    2146 </span>                :            :         /*
<span class="lineNum">    2147 </span>                :            :          * All objects in an encrypted objset are protected from modification
<span class="lineNum">    2148 </span>                :            :          * via a MAC. Encrypted objects store their IV and salt in the last DVA
<span class="lineNum">    2149 </span>                :            :          * in the bp, so we cannot use all copies. Encrypted objects are also
<span class="lineNum">    2150 </span>                :            :          * not subject to nopwrite since writing the same data will still
<span class="lineNum">    2151 </span>                :            :          * result in a new ciphertext. Only encrypted blocks can be dedup'd
<span class="lineNum">    2152 </span>                :            :          * to avoid ambiguity in the dedup code since the DDT does not store
<span class="lineNum">    2153 </span>                :            :          * object types.
<span class="lineNum">    2154 </span>                :            :          */
<span class="lineNum">    2155 </span>[<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 727807 times"> + </span>][<span class="branchNoExec" title="Branch 2 was not executed"> # </span><span class="branchNoExec" title="Branch 3 was not executed"> # </span>]:<span class="lineCov">     727807 :         if (os-&gt;os_encrypted &amp;&amp; (wp &amp; WP_NOFILL) == 0) {</span>
<span class="lineNum">    2156 </span>                :<span class="lineNoCov">          0 :                 encrypt = B_TRUE;</span>
<span class="lineNum">    2157 </span>                :            : 
<span class="lineNum">    2158 </span>[<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>][<span class="branchNoExec" title="Branch 2 was not executed"> # </span><span class="branchNoExec" title="Branch 3 was not executed"> # </span>]:<span class="lineNoCov">          0 :                 if (DMU_OT_IS_ENCRYPTED(type)) {</span>
<span class="lineNum">    2159 </span>                :<span class="lineNoCov">          0 :                         copies = MIN(copies, SPA_DVAS_PER_BP - 1);</span>
<span class="lineNum">    2160 </span>                :<span class="lineNoCov">          0 :                         nopwrite = B_FALSE;</span>
<span class="lineNum">    2161 </span>                :            :                 } else {
<span class="lineNum">    2162 </span>                :            :                         dedup = B_FALSE;
<span class="lineNum">    2163 </span>                :            :                 }
<span class="lineNum">    2164 </span>                :            : 
<span class="lineNum">    2165 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :                 if (type == DMU_OT_DNODE || type == DMU_OT_OBJSET)</span>
<span class="lineNum">    2166 </span>                :<span class="lineNoCov">          0 :                         compress = ZIO_COMPRESS_EMPTY;</span>
<span class="lineNum">    2167 </span>                :            :         }
<span class="lineNum">    2168 </span>                :            : 
<span class="lineNum">    2169 </span>                :<span class="lineCov">     727807 :         zp-&gt;zp_compress = compress;</span>
<span class="lineNum">    2170 </span>                :<span class="lineCov">     727807 :         zp-&gt;zp_checksum = checksum;</span>
<span class="lineNum">    2171 </span>        [<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 727807 times"> + </span>]:<span class="lineCov">     727807 :         zp-&gt;zp_type = (wp &amp; WP_SPILL) ? dn-&gt;dn_bonustype : type;</span>
<span class="lineNum">    2172 </span>                :<span class="lineCov">     727807 :         zp-&gt;zp_level = level;</span>
<span class="lineNum">    2173 </span>        [<span class="branchCov" title="Branch 1 was taken 401685 times"> + </span><span class="branchCov" title="Branch 2 was taken 326122 times"> + </span>]:<span class="lineCov">     727807 :         zp-&gt;zp_copies = MIN(copies, spa_max_replication(os-&gt;os_spa));</span>
<span class="lineNum">    2174 </span>                :<span class="lineCov">     727781 :         zp-&gt;zp_dedup = dedup;</span>
<span class="lineNum">    2175 </span>                :<span class="lineCov">     727781 :         zp-&gt;zp_dedup_verify = dedup &amp;&amp; dedup_verify;</span>
<span class="lineNum">    2176 </span>                :<span class="lineCov">     727781 :         zp-&gt;zp_nopwrite = nopwrite;</span>
<span class="lineNum">    2177 </span>                :<span class="lineCov">     727781 :         zp-&gt;zp_encrypt = encrypt;</span>
<span class="lineNum">    2178 </span>                :<span class="lineCov">     727781 :         zp-&gt;zp_byteorder = ZFS_HOST_BYTEORDER;</span>
<span class="lineNum">    2179 </span>                :<span class="lineCov">    1455562 :         bzero(zp-&gt;zp_salt, ZIO_DATA_SALT_LEN);</span>
<span class="lineNum">    2180 </span>                :<span class="lineCov">    1455562 :         bzero(zp-&gt;zp_iv, ZIO_DATA_IV_LEN);</span>
<span class="lineNum">    2181 </span>                :<span class="lineCov">    1455562 :         bzero(zp-&gt;zp_mac, ZIO_DATA_MAC_LEN);</span>
<span class="lineNum">    2182 </span>                :            : 
<span class="lineNum">    2183 </span>        [<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 727781 times"> + </span>]:<span class="lineCov">     727781 :         ASSERT3U(zp-&gt;zp_compress, !=, ZIO_COMPRESS_INHERIT);</span>
<span class="lineNum">    2184 </span>                :<span class="lineCov">     727781 : }</span>
<span class="lineNum">    2185 </span>                :            : 
<span class="lineNum">    2186 </span>                :            : /*
<span class="lineNum">    2187 </span>                :            :  * This function is only called from zfs_holey_common() for zpl_llseek()
<span class="lineNum">    2188 </span>                :            :  * in order to determine the location of holes.  In order to accurately
<span class="lineNum">    2189 </span>                :            :  * report holes all dirty data must be synced to disk.  This causes extremely
<span class="lineNum">    2190 </span>                :            :  * poor performance when seeking for holes in a dirty file.  As a compromise,
<span class="lineNum">    2191 </span>                :            :  * only provide hole data when the dnode is clean.  When a dnode is dirty
<span class="lineNum">    2192 </span>                :            :  * report the dnode as having no holes which is always a safe thing to do.
<a name="2193"><span class="lineNum">    2193 </span>                :            :  */</a>
<span class="lineNum">    2194 </span>                :            : int
<span class="lineNum">    2195 </span>                :<span class="lineNoCov">          0 : dmu_offset_next(objset_t *os, uint64_t object, boolean_t hole, uint64_t *off)</span>
<span class="lineNum">    2196 </span>                :            : {
<span class="lineNum">    2197 </span>                :            :         dnode_t *dn;
<span class="lineNum">    2198 </span>                :            :         int i, err;
<span class="lineNum">    2199 </span>                :<span class="lineNoCov">          0 :         boolean_t clean = B_TRUE;</span>
<span class="lineNum">    2200 </span>                :            : 
<span class="lineNum">    2201 </span>                :<span class="lineNoCov">          0 :         err = dnode_hold(os, object, FTAG, &amp;dn);</span>
<span class="lineNum">    2202 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :         if (err)</span>
<span class="lineNum">    2203 </span>                :            :                 return (err);
<span class="lineNum">    2204 </span>                :            : 
<span class="lineNum">    2205 </span>                :            :         /*
<span class="lineNum">    2206 </span>                :            :          * Check if dnode is dirty
<span class="lineNum">    2207 </span>                :            :          */
<span class="lineNum">    2208 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :         if (dn-&gt;dn_dirtyctx != DN_UNDIRTIED) {</span>
<span class="lineNum">    2209 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :                 for (i = 0; i &lt; TXG_SIZE; i++) {</span>
<span class="lineNum">    2210 </span>        [<span class="branchNoExec" title="Branch 1 was not executed"> # </span><span class="branchNoExec" title="Branch 2 was not executed"> # </span>]:<span class="lineNoCov">          0 :                         if (!list_is_empty(&amp;dn-&gt;dn_dirty_records[i])) {</span>
<span class="lineNum">    2211 </span>                :            :                                 clean = B_FALSE;
<span class="lineNum">    2212 </span>                :            :                                 break;
<span class="lineNum">    2213 </span>                :            :                         }
<span class="lineNum">    2214 </span>                :            :                 }
<span class="lineNum">    2215 </span>                :            :         }
<span class="lineNum">    2216 </span>                :            : 
<span class="lineNum">    2217 </span>                :            :         /*
<span class="lineNum">    2218 </span>                :            :          * If compatibility option is on, sync any current changes before
<span class="lineNum">    2219 </span>                :            :          * we go trundling through the block pointers.
<span class="lineNum">    2220 </span>                :            :          */
<span class="lineNum">    2221 </span>[<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>][<span class="branchNoExec" title="Branch 2 was not executed"> # </span><span class="branchNoExec" title="Branch 3 was not executed"> # </span>]:<span class="lineNoCov">          0 :         if (!clean &amp;&amp; zfs_dmu_offset_next_sync) {</span>
<span class="lineNum">    2222 </span>                :<span class="lineNoCov">          0 :                 clean = B_TRUE;</span>
<span class="lineNum">    2223 </span>                :<span class="lineNoCov">          0 :                 dnode_rele(dn, FTAG);</span>
<span class="lineNum">    2224 </span>                :<span class="lineNoCov">          0 :                 txg_wait_synced(dmu_objset_pool(os), 0);</span>
<span class="lineNum">    2225 </span>                :<span class="lineNoCov">          0 :                 err = dnode_hold(os, object, FTAG, &amp;dn);</span>
<span class="lineNum">    2226 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :                 if (err)</span>
<span class="lineNum">    2227 </span>                :            :                         return (err);
<span class="lineNum">    2228 </span>                :            :         }
<span class="lineNum">    2229 </span>                :            : 
<span class="lineNum">    2230 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :         if (clean)</span>
<span class="lineNum">    2231 </span>                :<span class="lineNoCov">          0 :                 err = dnode_next_offset(dn,</span>
<span class="lineNum">    2232 </span>                :            :                     (hole ? DNODE_FIND_HOLE : 0), off, 1, 1, 0);
<span class="lineNum">    2233 </span>                :            :         else
<span class="lineNum">    2234 </span>                :<span class="lineNoCov">          0 :                 err = SET_ERROR(EBUSY);</span>
<span class="lineNum">    2235 </span>                :            : 
<span class="lineNum">    2236 </span>                :<span class="lineNoCov">          0 :         dnode_rele(dn, FTAG);</span>
<span class="lineNum">    2237 </span>                :            : 
<span class="lineNum">    2238 </span>                :<span class="lineNoCov">          0 :         return (err);</span>
<span class="lineNum">    2239 </span>                :            : }
<a name="2240"><span class="lineNum">    2240 </span>                :            : </a>
<span class="lineNum">    2241 </span>                :            : void
<span class="lineNum">    2242 </span>                :<span class="lineCov">    2560133 : __dmu_object_info_from_dnode(dnode_t *dn, dmu_object_info_t *doi)</span>
<span class="lineNum">    2243 </span>                :            : {
<span class="lineNum">    2244 </span>                :<span class="lineCov">    2560133 :         dnode_phys_t *dnp = dn-&gt;dn_phys;</span>
<span class="lineNum">    2245 </span>                :            :         int i;
<span class="lineNum">    2246 </span>                :            : 
<span class="lineNum">    2247 </span>                :<span class="lineCov">    2560133 :         doi-&gt;doi_data_block_size = dn-&gt;dn_datablksz;</span>
<span class="lineNum">    2248 </span>        [<span class="branchCov" title="Branch 0 was taken 2559150 times"> + </span><span class="branchCov" title="Branch 1 was taken 983 times"> + </span>]:<span class="lineCov">    2560133 :         doi-&gt;doi_metadata_block_size = dn-&gt;dn_indblkshift ?</span>
<span class="lineNum">    2249 </span>                :<span class="lineCov">    2559150 :             1ULL &lt;&lt; dn-&gt;dn_indblkshift : 0;</span>
<span class="lineNum">    2250 </span>                :<span class="lineCov">    2560133 :         doi-&gt;doi_type = dn-&gt;dn_type;</span>
<span class="lineNum">    2251 </span>                :<span class="lineCov">    2560133 :         doi-&gt;doi_bonus_type = dn-&gt;dn_bonustype;</span>
<span class="lineNum">    2252 </span>                :<span class="lineCov">    2560133 :         doi-&gt;doi_bonus_size = dn-&gt;dn_bonuslen;</span>
<span class="lineNum">    2253 </span>                :<span class="lineCov">    2560133 :         doi-&gt;doi_dnodesize = dn-&gt;dn_num_slots &lt;&lt; DNODE_SHIFT;</span>
<span class="lineNum">    2254 </span>                :<span class="lineCov">    2560133 :         doi-&gt;doi_indirection = dn-&gt;dn_nlevels;</span>
<span class="lineNum">    2255 </span>                :<span class="lineCov">    2560133 :         doi-&gt;doi_checksum = dn-&gt;dn_checksum;</span>
<span class="lineNum">    2256 </span>                :<span class="lineCov">    2560133 :         doi-&gt;doi_compress = dn-&gt;dn_compress;</span>
<span class="lineNum">    2257 </span>                :<span class="lineCov">    2560133 :         doi-&gt;doi_nblkptr = dn-&gt;dn_nblkptr;</span>
<span class="lineNum">    2258 </span>        [<span class="branchCov" title="Branch 0 was taken 1899252 times"> + </span><span class="branchCov" title="Branch 1 was taken 660881 times"> + </span>]:<span class="lineCov">    2560133 :         doi-&gt;doi_physical_blocks_512 = (DN_USED_BYTES(dnp) + 256) &gt;&gt; 9;</span>
<span class="lineNum">    2259 </span>                :<span class="lineCov">    2560133 :         doi-&gt;doi_max_offset = (dn-&gt;dn_maxblkid + 1) * dn-&gt;dn_datablksz;</span>
<span class="lineNum">    2260 </span>                :<span class="lineCov">    2560133 :         doi-&gt;doi_fill_count = 0;</span>
<span class="lineNum">    2261 </span>        [<span class="branchCov" title="Branch 0 was taken 4871291 times"> + </span><span class="branchCov" title="Branch 1 was taken 2560133 times"> + </span>]:<span class="lineCov">    7431424 :         for (i = 0; i &lt; dnp-&gt;dn_nblkptr; i++)</span>
<span class="lineNum">    2262 </span>[<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 4871291 times"> + </span>][<span class="branchNoExec" title="Branch 2 was not executed"> # </span><span class="branchNoExec" title="Branch 3 was not executed"> # </span>]:<span class="lineCov">    4871291 :                 doi-&gt;doi_fill_count += BP_GET_FILL(&amp;dnp-&gt;dn_blkptr[i]);</span>
<span class="lineNum">         </span>[<span class="branchNoExec" title="Branch 4 was not executed"> # </span><span class="branchNoExec" title="Branch 5 was not executed"> # </span>][<span class="branchNoExec" title="Branch 6 was not executed"> # </span><span class="branchNoExec" title="Branch 7 was not executed"> # </span>]
<span class="lineNum">         </span>[<span class="branchNoExec" title="Branch 8 was not executed"> # </span><span class="branchNoExec" title="Branch 9 was not executed"> # </span>][<span class="branchCov" title="Branch 10 was taken 3555063 times"> + </span><span class="branchCov" title="Branch 11 was taken 1316228 times"> + </span>]
<span class="lineNum">    2263 </span>                :<span class="lineCov">    2560133 : }</span>
<a name="2264"><span class="lineNum">    2264 </span>                :            : </a>
<span class="lineNum">    2265 </span>                :            : void
<span class="lineNum">    2266 </span>                :<span class="lineCov">    2560231 : dmu_object_info_from_dnode(dnode_t *dn, dmu_object_info_t *doi)</span>
<span class="lineNum">    2267 </span>                :            : {
<span class="lineNum">    2268 </span>                :<span class="lineCov">    2560231 :         rw_enter(&amp;dn-&gt;dn_struct_rwlock, RW_READER);</span>
<span class="lineNum">    2269 </span>                :<span class="lineCov">    2560800 :         mutex_enter(&amp;dn-&gt;dn_mtx);</span>
<span class="lineNum">    2270 </span>                :            : 
<span class="lineNum">    2271 </span>                :<span class="lineCov">    2560718 :         __dmu_object_info_from_dnode(dn, doi);</span>
<span class="lineNum">    2272 </span>                :            : 
<span class="lineNum">    2273 </span>                :<span class="lineCov">    2560099 :         mutex_exit(&amp;dn-&gt;dn_mtx);</span>
<span class="lineNum">    2274 </span>                :<span class="lineCov">    2560258 :         rw_exit(&amp;dn-&gt;dn_struct_rwlock);</span>
<span class="lineNum">    2275 </span>                :<span class="lineCov">    2560614 : }</span>
<span class="lineNum">    2276 </span>                :            : 
<span class="lineNum">    2277 </span>                :            : /*
<span class="lineNum">    2278 </span>                :            :  * Get information on a DMU object.
<span class="lineNum">    2279 </span>                :            :  * If doi is NULL, just indicates whether the object exists.
<a name="2280"><span class="lineNum">    2280 </span>                :            :  */</a>
<span class="lineNum">    2281 </span>                :            : int
<span class="lineNum">    2282 </span>                :<span class="lineCov">     710408 : dmu_object_info(objset_t *os, uint64_t object, dmu_object_info_t *doi)</span>
<span class="lineNum">    2283 </span>                :            : {
<span class="lineNum">    2284 </span>                :            :         dnode_t *dn;
<span class="lineNum">    2285 </span>                :<span class="lineCov">     710408 :         int err = dnode_hold(os, object, FTAG, &amp;dn);</span>
<span class="lineNum">    2286 </span>                :            : 
<span class="lineNum">    2287 </span>        [<span class="branchCov" title="Branch 0 was taken 425589 times"> + </span><span class="branchCov" title="Branch 1 was taken 284820 times"> + </span>]:<span class="lineCov">     710409 :         if (err)</span>
<span class="lineNum">    2288 </span>                :            :                 return (err);
<span class="lineNum">    2289 </span>                :            : 
<span class="lineNum">    2290 </span>        [<span class="branchCov" title="Branch 0 was taken 422186 times"> + </span><span class="branchCov" title="Branch 1 was taken 3403 times"> + </span>]:<span class="lineCov">     425589 :         if (doi != NULL)</span>
<span class="lineNum">    2291 </span>                :<span class="lineCov">     422186 :                 dmu_object_info_from_dnode(dn, doi);</span>
<span class="lineNum">    2292 </span>                :            : 
<span class="lineNum">    2293 </span>                :<span class="lineCov">     425588 :         dnode_rele(dn, FTAG);</span>
<span class="lineNum">    2294 </span>                :<span class="lineCov">     425590 :         return (0);</span>
<span class="lineNum">    2295 </span>                :            : }
<span class="lineNum">    2296 </span>                :            : 
<span class="lineNum">    2297 </span>                :            : /*
<span class="lineNum">    2298 </span>                :            :  * As above, but faster; can be used when you have a held dbuf in hand.
<a name="2299"><span class="lineNum">    2299 </span>                :            :  */</a>
<span class="lineNum">    2300 </span>                :            : void
<span class="lineNum">    2301 </span>                :<span class="lineCov">    2132961 : dmu_object_info_from_db(dmu_buf_t *db_fake, dmu_object_info_t *doi)</span>
<span class="lineNum">    2302 </span>                :            : {
<span class="lineNum">    2303 </span>                :<span class="lineCov">    2132961 :         dmu_buf_impl_t *db = (dmu_buf_impl_t *)db_fake;</span>
<span class="lineNum">    2304 </span>                :            : 
<span class="lineNum">    2305 </span>                :<span class="lineCov">    2132961 :         DB_DNODE_ENTER(db);</span>
<span class="lineNum">    2306 </span>                :<span class="lineCov">    2135554 :         dmu_object_info_from_dnode(DB_DNODE(db), doi);</span>
<span class="lineNum">    2307 </span>                :<span class="lineCov">    2135432 :         DB_DNODE_EXIT(db);</span>
<span class="lineNum">    2308 </span>                :<span class="lineCov">    2135518 : }</span>
<span class="lineNum">    2309 </span>                :            : 
<span class="lineNum">    2310 </span>                :            : /*
<span class="lineNum">    2311 </span>                :            :  * Faster still when you only care about the size.
<span class="lineNum">    2312 </span>                :            :  * This is specifically optimized for zfs_getattr().
<a name="2313"><span class="lineNum">    2313 </span>                :            :  */</a>
<span class="lineNum">    2314 </span>                :            : void
<span class="lineNum">    2315 </span>                :<span class="lineCov">      12785 : dmu_object_size_from_db(dmu_buf_t *db_fake, uint32_t *blksize,</span>
<span class="lineNum">    2316 </span>                :            :     u_longlong_t *nblk512)
<span class="lineNum">    2317 </span>                :            : {
<span class="lineNum">    2318 </span>                :<span class="lineCov">      12785 :         dmu_buf_impl_t *db = (dmu_buf_impl_t *)db_fake;</span>
<span class="lineNum">    2319 </span>                :            :         dnode_t *dn;
<span class="lineNum">    2320 </span>                :            : 
<span class="lineNum">    2321 </span>                :<span class="lineCov">      12785 :         DB_DNODE_ENTER(db);</span>
<span class="lineNum">    2322 </span>                :<span class="lineCov">      12785 :         dn = DB_DNODE(db);</span>
<span class="lineNum">    2323 </span>                :            : 
<span class="lineNum">    2324 </span>                :<span class="lineCov">      12785 :         *blksize = dn-&gt;dn_datablksz;</span>
<span class="lineNum">    2325 </span>                :            :         /* add in number of slots used for the dnode itself */
<span class="lineNum">    2326 </span>        [<span class="branchCov" title="Branch 0 was taken 11928 times"> + </span><span class="branchCov" title="Branch 1 was taken 857 times"> + </span>]:<span class="lineCov">      12785 :         *nblk512 = ((DN_USED_BYTES(dn-&gt;dn_phys) + SPA_MINBLOCKSIZE/2) &gt;&gt;</span>
<span class="lineNum">    2327 </span>                :<span class="lineCov">      12785 :             SPA_MINBLOCKSHIFT) + dn-&gt;dn_num_slots;</span>
<span class="lineNum">    2328 </span>                :<span class="lineCov">      12785 :         DB_DNODE_EXIT(db);</span>
<span class="lineNum">    2329 </span>                :<span class="lineCov">      12785 : }</span>
<a name="2330"><span class="lineNum">    2330 </span>                :            : </a>
<span class="lineNum">    2331 </span>                :            : void
<span class="lineNum">    2332 </span>                :<span class="lineNoCov">          0 : dmu_object_dnsize_from_db(dmu_buf_t *db_fake, int *dnsize)</span>
<span class="lineNum">    2333 </span>                :            : {
<span class="lineNum">    2334 </span>                :<span class="lineNoCov">          0 :         dmu_buf_impl_t *db = (dmu_buf_impl_t *)db_fake;</span>
<span class="lineNum">    2335 </span>                :            :         dnode_t *dn;
<span class="lineNum">    2336 </span>                :            : 
<span class="lineNum">    2337 </span>                :<span class="lineNoCov">          0 :         DB_DNODE_ENTER(db);</span>
<span class="lineNum">    2338 </span>                :<span class="lineNoCov">          0 :         dn = DB_DNODE(db);</span>
<span class="lineNum">    2339 </span>                :<span class="lineNoCov">          0 :         *dnsize = dn-&gt;dn_num_slots &lt;&lt; DNODE_SHIFT;</span>
<span class="lineNum">    2340 </span>                :<span class="lineNoCov">          0 :         DB_DNODE_EXIT(db);</span>
<span class="lineNum">    2341 </span>                :<span class="lineNoCov">          0 : }</span>
<a name="2342"><span class="lineNum">    2342 </span>                :            : </a>
<span class="lineNum">    2343 </span>                :            : void
<span class="lineNum">    2344 </span>                :<span class="lineCov">      11840 : byteswap_uint64_array(void *vbuf, size_t size)</span>
<span class="lineNum">    2345 </span>                :            : {
<span class="lineNum">    2346 </span>                :<span class="lineCov">      11840 :         uint64_t *buf = vbuf;</span>
<span class="lineNum">    2347 </span>                :<span class="lineCov">      11840 :         size_t count = size &gt;&gt; 3;</span>
<span class="lineNum">    2348 </span>                :            :         int i;
<span class="lineNum">    2349 </span>                :            : 
<span class="lineNum">    2350 </span>        [<span class="branchCov" title="Branch 0 was taken 11840 times"> + </span><span class="branchNoCov" title="Branch 1 was not taken"> - </span>]:<span class="lineCov">      11840 :         ASSERT((size &amp; 7) == 0);</span>
<span class="lineNum">    2351 </span>                :            : 
<span class="lineNum">    2352 </span>        [<span class="branchCov" title="Branch 0 was taken 51936 times"> + </span><span class="branchCov" title="Branch 1 was taken 11840 times"> + </span>]:<span class="lineCov">      63776 :         for (i = 0; i &lt; count; i++)</span>
<span class="lineNum">    2353 </span>                :<span class="lineCov">      51936 :                 buf[i] = BSWAP_64(buf[i]);</span>
<span class="lineNum">    2354 </span>                :<span class="lineCov">      11840 : }</span>
<a name="2355"><span class="lineNum">    2355 </span>                :            : </a>
<span class="lineNum">    2356 </span>                :            : void
<span class="lineNum">    2357 </span>                :<span class="lineNoCov">          0 : byteswap_uint32_array(void *vbuf, size_t size)</span>
<span class="lineNum">    2358 </span>                :            : {
<span class="lineNum">    2359 </span>                :<span class="lineNoCov">          0 :         uint32_t *buf = vbuf;</span>
<span class="lineNum">    2360 </span>                :<span class="lineNoCov">          0 :         size_t count = size &gt;&gt; 2;</span>
<span class="lineNum">    2361 </span>                :            :         int i;
<span class="lineNum">    2362 </span>                :            : 
<span class="lineNum">    2363 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :         ASSERT((size &amp; 3) == 0);</span>
<span class="lineNum">    2364 </span>                :            : 
<span class="lineNum">    2365 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :         for (i = 0; i &lt; count; i++)</span>
<span class="lineNum">    2366 </span>                :<span class="lineNoCov">          0 :                 buf[i] = BSWAP_32(buf[i]);</span>
<span class="lineNum">    2367 </span>                :<span class="lineNoCov">          0 : }</span>
<a name="2368"><span class="lineNum">    2368 </span>                :            : </a>
<span class="lineNum">    2369 </span>                :            : void
<span class="lineNum">    2370 </span>                :<span class="lineNoCov">          0 : byteswap_uint16_array(void *vbuf, size_t size)</span>
<span class="lineNum">    2371 </span>                :            : {
<span class="lineNum">    2372 </span>                :<span class="lineNoCov">          0 :         uint16_t *buf = vbuf;</span>
<span class="lineNum">    2373 </span>                :<span class="lineNoCov">          0 :         size_t count = size &gt;&gt; 1;</span>
<span class="lineNum">    2374 </span>                :            :         int i;
<span class="lineNum">    2375 </span>                :            : 
<span class="lineNum">    2376 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :         ASSERT((size &amp; 1) == 0);</span>
<span class="lineNum">    2377 </span>                :            : 
<span class="lineNum">    2378 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :         for (i = 0; i &lt; count; i++)</span>
<span class="lineNum">    2379 </span>                :<span class="lineNoCov">          0 :                 buf[i] = BSWAP_16(buf[i]);</span>
<span class="lineNum">    2380 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2381 </span>                :            : 
<a name="2382"><span class="lineNum">    2382 </span>                :            : /* ARGSUSED */</a>
<span class="lineNum">    2383 </span>                :            : void
<span class="lineNum">    2384 </span>                :<span class="lineNoCov">          0 : byteswap_uint8_array(void *vbuf, size_t size)</span>
<span class="lineNum">    2385 </span>                :            : {
<span class="lineNum">    2386 </span>                :<span class="lineNoCov">          0 : }</span>
<a name="2387"><span class="lineNum">    2387 </span>                :            : </a>
<span class="lineNum">    2388 </span>                :            : void
<span class="lineNum">    2389 </span>                :<span class="lineCov">       1234 : dmu_init(void)</span>
<span class="lineNum">    2390 </span>                :            : {
<span class="lineNum">    2391 </span>                :<span class="lineCov">       1234 :         abd_init();</span>
<span class="lineNum">    2392 </span>                :<span class="lineCov">       1234 :         zfs_dbgmsg_init();</span>
<span class="lineNum">    2393 </span>                :<span class="lineCov">       1234 :         sa_cache_init();</span>
<span class="lineNum">    2394 </span>                :<span class="lineCov">       1234 :         xuio_stat_init();</span>
<span class="lineNum">    2395 </span>                :<span class="lineCov">       1234 :         dmu_objset_init();</span>
<span class="lineNum">    2396 </span>                :<span class="lineCov">       1234 :         dnode_init();</span>
<span class="lineNum">    2397 </span>                :<span class="lineCov">       1234 :         zfetch_init();</span>
<span class="lineNum">    2398 </span>                :<span class="lineCov">       1234 :         dmu_tx_init();</span>
<span class="lineNum">    2399 </span>                :<span class="lineCov">       1234 :         l2arc_init();</span>
<span class="lineNum">    2400 </span>                :<span class="lineCov">       1234 :         arc_init();</span>
<span class="lineNum">    2401 </span>                :<span class="lineCov">       1234 :         dbuf_init();</span>
<span class="lineNum">    2402 </span>                :<span class="lineCov">       1234 : }</span>
<a name="2403"><span class="lineNum">    2403 </span>                :            : </a>
<span class="lineNum">    2404 </span>                :            : void
<span class="lineNum">    2405 </span>                :<span class="lineCov">        785 : dmu_fini(void)</span>
<span class="lineNum">    2406 </span>                :            : {
<span class="lineNum">    2407 </span>                :<span class="lineCov">        785 :         arc_fini(); /* arc depends on l2arc, so arc must go first */</span>
<span class="lineNum">    2408 </span>                :<span class="lineCov">        785 :         l2arc_fini();</span>
<span class="lineNum">    2409 </span>                :<span class="lineCov">        785 :         dmu_tx_fini();</span>
<span class="lineNum">    2410 </span>                :<span class="lineCov">        785 :         zfetch_fini();</span>
<span class="lineNum">    2411 </span>                :<span class="lineCov">        785 :         dbuf_fini();</span>
<span class="lineNum">    2412 </span>                :<span class="lineCov">        785 :         dnode_fini();</span>
<span class="lineNum">    2413 </span>                :<span class="lineCov">        785 :         dmu_objset_fini();</span>
<span class="lineNum">    2414 </span>                :<span class="lineCov">        785 :         xuio_stat_fini();</span>
<span class="lineNum">    2415 </span>                :<span class="lineCov">        785 :         sa_cache_fini();</span>
<span class="lineNum">    2416 </span>                :<span class="lineCov">        785 :         zfs_dbgmsg_fini();</span>
<span class="lineNum">    2417 </span>                :<span class="lineCov">        785 :         abd_fini();</span>
<span class="lineNum">    2418 </span>                :<span class="lineCov">        785 : }</span>
<span class="lineNum">    2419 </span>                :            : 
<span class="lineNum">    2420 </span>                :            : #if defined(_KERNEL) &amp;&amp; defined(HAVE_SPL)
<span class="lineNum">    2421 </span>                :            : EXPORT_SYMBOL(dmu_bonus_hold);
<span class="lineNum">    2422 </span>                :            : EXPORT_SYMBOL(dmu_buf_hold_array_by_bonus);
<span class="lineNum">    2423 </span>                :            : EXPORT_SYMBOL(dmu_buf_rele_array);
<span class="lineNum">    2424 </span>                :            : EXPORT_SYMBOL(dmu_prefetch);
<span class="lineNum">    2425 </span>                :            : EXPORT_SYMBOL(dmu_free_range);
<span class="lineNum">    2426 </span>                :            : EXPORT_SYMBOL(dmu_free_long_range);
<span class="lineNum">    2427 </span>                :            : EXPORT_SYMBOL(dmu_free_long_object);
<span class="lineNum">    2428 </span>                :            : EXPORT_SYMBOL(dmu_read);
<span class="lineNum">    2429 </span>                :            : EXPORT_SYMBOL(dmu_read_by_dnode);
<span class="lineNum">    2430 </span>                :            : EXPORT_SYMBOL(dmu_write);
<span class="lineNum">    2431 </span>                :            : EXPORT_SYMBOL(dmu_write_by_dnode);
<span class="lineNum">    2432 </span>                :            : EXPORT_SYMBOL(dmu_prealloc);
<span class="lineNum">    2433 </span>                :            : EXPORT_SYMBOL(dmu_object_info);
<span class="lineNum">    2434 </span>                :            : EXPORT_SYMBOL(dmu_object_info_from_dnode);
<span class="lineNum">    2435 </span>                :            : EXPORT_SYMBOL(dmu_object_info_from_db);
<span class="lineNum">    2436 </span>                :            : EXPORT_SYMBOL(dmu_object_size_from_db);
<span class="lineNum">    2437 </span>                :            : EXPORT_SYMBOL(dmu_object_dnsize_from_db);
<span class="lineNum">    2438 </span>                :            : EXPORT_SYMBOL(dmu_object_set_nlevels);
<span class="lineNum">    2439 </span>                :            : EXPORT_SYMBOL(dmu_object_set_blocksize);
<span class="lineNum">    2440 </span>                :            : EXPORT_SYMBOL(dmu_object_set_checksum);
<span class="lineNum">    2441 </span>                :            : EXPORT_SYMBOL(dmu_object_set_compress);
<span class="lineNum">    2442 </span>                :            : EXPORT_SYMBOL(dmu_write_policy);
<span class="lineNum">    2443 </span>                :            : EXPORT_SYMBOL(dmu_sync);
<span class="lineNum">    2444 </span>                :            : EXPORT_SYMBOL(dmu_request_arcbuf);
<span class="lineNum">    2445 </span>                :            : EXPORT_SYMBOL(dmu_return_arcbuf);
<span class="lineNum">    2446 </span>                :            : EXPORT_SYMBOL(dmu_assign_arcbuf);
<span class="lineNum">    2447 </span>                :            : EXPORT_SYMBOL(dmu_buf_hold);
<span class="lineNum">    2448 </span>                :            : EXPORT_SYMBOL(dmu_ot);
<span class="lineNum">    2449 </span>                :            : 
<span class="lineNum">    2450 </span>                :            : /* BEGIN CSTYLED */
<span class="lineNum">    2451 </span>                :            : module_param(zfs_mdcomp_disable, int, 0644);
<span class="lineNum">    2452 </span>                :            : MODULE_PARM_DESC(zfs_mdcomp_disable, &quot;Disable meta data compression&quot;);
<span class="lineNum">    2453 </span>                :            : 
<span class="lineNum">    2454 </span>                :            : module_param(zfs_nopwrite_enabled, int, 0644);
<span class="lineNum">    2455 </span>                :            : MODULE_PARM_DESC(zfs_nopwrite_enabled, &quot;Enable NOP writes&quot;);
<span class="lineNum">    2456 </span>                :            : 
<span class="lineNum">    2457 </span>                :            : module_param(zfs_per_txg_dirty_frees_percent, ulong, 0644);
<span class="lineNum">    2458 </span>                :            : MODULE_PARM_DESC(zfs_per_txg_dirty_frees_percent,
<span class="lineNum">    2459 </span>                :            :         &quot;percentage of dirtied blocks from frees in one TXG&quot;);
<span class="lineNum">    2460 </span>                :            : 
<span class="lineNum">    2461 </span>                :            : module_param(zfs_dmu_offset_next_sync, int, 0644);
<span class="lineNum">    2462 </span>                :            : MODULE_PARM_DESC(zfs_dmu_offset_next_sync,
<span class="lineNum">    2463 </span>                :            :         &quot;Enable forcing txg sync to find holes&quot;);
<span class="lineNum">    2464 </span>                :            : 
<span class="lineNum">    2465 </span>                :            : /* END CSTYLED */
<span class="lineNum">    2466 </span>                :            : 
<span class="lineNum">    2467 </span>                :            : #endif
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
