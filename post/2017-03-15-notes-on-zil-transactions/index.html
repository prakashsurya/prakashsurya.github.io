<!DOCTYPE html>
<html>
  <head>
    <meta name="generator" content="Hugo 0.18.1" />
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="canonical" href="https://www.prakashsurya.com/post/2017-03-15-notes-on-zil-transactions/">
<link rel="stylesheet" type="text/css" href="/css/hack.css">
<link rel="stylesheet" type="text/css" href="/css/custom.css">

    <title>
  OpenZFS: Notes on ZIL Transactions &raquo; www.prakashsurya.com
</title>
  </head>
  <body class="hack container">
    <header>
      <nav>
  
    <a class="active" href="/">Home</a>
  
    <a class="active" href="/post/">Posts</a>
  
    <a class="active" href="/link/">Links</a>
  
</nav>

    </header>
    <main>
  <h1>OpenZFS: Notes on ZIL Transactions</h1>
  <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#zfs-intent-log-transactions">ZFS Intent Log Transactions</a>
<ul>
<li><a href="#in-memory-representation-of-zil-transactions">In-Memory Representation of ZIL Transactions</a></li>
<li><a href="#determing-the-type-of-a-zil-transaction">Determing the Type of a ZIL Transaction</a></li>
</ul></li>
<li><a href="#zil-transactions-by-example">ZIL Transactions by Example</a>
<ul>
<li><a href="#accessing-the-in-memory-zil-structure">Accessing the In-Memory ZIL Structure</a></li>
<li><a href="#zil-transaction-creation-and-assignment">ZIL Transaction Creation and Assignment</a>
<ul>
<li><a href="#zil-itx-create"><code>zil_itx_create</code></a></li>
<li><a href="#zil-itx-assign"><code>zil_itx_assign</code></a></li>
</ul></li>
<li><a href="#zl-itxg-4-i-sync-list-i-async-tree-and-ia-list"><code>zl_itxg[4]</code>, <code>i_sync_list</code>, <code>i_async_tree</code>, and <code>ia_list</code></a></li>
<li><a href="#insertion-of-a-zil-transaction">Insertion of a ZIL Transaction</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
  

<h2 id="introduction">Introduction</h2>

<p>The <a href="http://open-zfs.org">OpenZFS</a> <a href="http://nex7.blogspot.com/2013/04/zfs-intent-log.html">Intent Log</a> (ZIL) is used to ensure <a href="https://en.wikipedia.org/wiki/POSIX">POSIX</a>
compliance of certain system calls (that modify the state of a ZFS
dataset), and protect against data loss in the face of failure scenarios
such as: an operating system crash, power loss, etc. Specifically, it&rsquo;s
used as a performance optimization so that applications can be assured
that their given system call, and any &ldquo;user data&rdquo; associated with it,
will not be &ldquo;lost&rdquo;, without having to wait for an entire <a href="https://www.delphix.com/blog/delphix-engineering/zfs-fundamentals-transaction-groups">transaction
group</a> (TXG) to be synced out (which can take on the order of
seconds, on a moderately loaded system).</p>

<p>So how does this process work? How are these system calls tracked? This
post will attempt to explain how the system calls enter the ZIL, and how
they&rsquo;re tracked by the in-memory portion of the ZIL. What isn&rsquo;t covered
in this post is how the in-memory representation of the system calls get
written to disk, nor how the on-disk ZIL is used to &ldquo;replay&rdquo; the system
calls after a failure event.</p>

<h2 id="zfs-intent-log-transactions">ZFS Intent Log Transactions</h2>

<p>Much like how ZFS&rsquo;s DMU layer operates on the notion of &ldquo;transactions&rdquo;,
so does the ZIL. For each system call that modifies a dataset&rsquo;s state, a
ZIL transaction is created; referred to as an <code>itx</code> in the code and this
document. It&rsquo;s important to note, these <code>itx</code>&rsquo;s are created for
&ldquo;synchronous&rdquo; system calls, as well as &ldquo;asynchronous&rdquo; ones. For example,
an <code>itx</code> will be generated by an application calling <code>write</code> on a ZFS
dataset, whether the <code>O_SYNC</code> flag is used or not. Additionally, <em>all</em>
system calls that modify a dataset will cause an <code>itx</code> to be generated;
e.g. <code>write</code>, <code>rename</code>, <code>setattr</code>, etc. all will generate an <code>itx</code>
unique to that system call.</p>

<h3 id="in-memory-representation-of-zil-transactions">In-Memory Representation of ZIL Transactions</h3>

<p>Each <code>itx</code> is composed of an <code>itx_t</code>, as well as a system call specific
component. The <code>itx_t</code> portion looks like this:</p>

<pre><code>typedef struct itx {
	list_node_t	itx_node;	/* linkage on zl_itx_list */
	void		*itx_private;	/* type-specific opaque data */
	itx_wr_state_t	itx_wr_state;	/* write state */
	uint8_t		itx_sync;	/* synchronous transaction */
	uint64_t	itx_sod;	/* record size on disk */
	uint64_t	itx_oid;	/* object id */
	lr_t		itx_lr;		/* common part of log record */
	/* followed by type-specific part of lr_xx_t and its immediate data */
} itx_t;
</code></pre>

<p>And for a <code>write</code> system call, the <code>lr_write_t</code> structure would be
tacked onto the end of the <code>itx_t</code>; this structure looks like this:</p>

<pre><code>typedef struct {
	lr_t		lr_common;	/* common portion of log record */
	uint64_t	lr_foid;	/* file object to write */
	uint64_t	lr_offset;	/* offset to write to */
	uint64_t	lr_length;	/* user data length to write */
	uint64_t	lr_blkoff;	/* no longer used */
	blkptr_t	lr_blkptr;	/* spa block pointer for replay */
	/* write data will follow for small writes */
} lr_write_t;
</code></pre>

<p>Thus, the in-memory representation for a <code>write</code> <code>itx</code> actually looks
like the following (assuming a small amount of data is being written):</p>

<pre><code>struct {
	itx_t common;
	lr_write_t uncommon;
	void *data;
};
</code></pre>

<p>The portion of the structure that&rsquo;s common to all <code>itx</code> types starts at
offset 0, the write specific portion immediately follows the <code>itx_t</code>,
and then finally the user-data that is being written.</p>

<h3 id="determing-the-type-of-a-zil-transaction">Determing the Type of a ZIL Transaction</h3>

<p>Since the last structure depicted in the previous section doesn&rsquo;t
actually exist, it&rsquo;s important to understand how the code is able to
determine which structure follows the <code>itx_t</code> portion of an <code>itx</code>; since
it could be any one of the many options (e.g. <code>lr_write_t</code>,
<code>lr_rename_t</code>, <code>lr_setattr_t</code>, etc).</p>

<p>The <code>lr_t</code> contained within the <code>itx_t</code> is used for this purpose. It
contains an <code>lrc_txtype</code> field, which can be used to determine the
<code>itx</code>&rsquo;s type. For example, if the <code>itx</code> was for a <code>write</code>, <code>lrc_tx_type</code>
would equal <code>TX_WRITE</code>, and the <code>lr_write_t</code> could be obtained like so:</p>

<pre><code>ASSERT(itx-&gt;itx_lr.lrc_txtype == TX_WRITE);
lr_write_t *lr = (lr_write_t *)&amp;itx-&gt;itx_lr;
</code></pre>

<h2 id="zil-transactions-by-example">ZIL Transactions by Example</h2>

<p>Now that we have a brief understanding of what an <code>itx</code> is, lets look at
how these are generated and added to the ZIL; we&rsquo;ll be using
<code>zfs_write</code> as the example code path.</p>

<h3 id="accessing-the-in-memory-zil-structure">Accessing the In-Memory ZIL Structure</h3>

<p>The first line of code within <code>zfs_write</code> that pertains to the ZIL&rsquo;s
machinery is this:</p>

<pre><code>zilog = zfsvfs-&gt;z_log;
</code></pre>

<p>In order to manipulate the ZIL, a pointer to the ZIL structure (i.e. the
<code>zilog_t</code>) is needed. This is obtained using the <code>vnode_t</code> (passed in as
a parameter to <code>zfs_write</code>) to extract a pointer to the corresponding
<code>znode_t</code>; the <code>v_data</code> field of the <code>vnode_t</code> holds a pointer to the
<code>znode_t</code>. Once we have the <code>znode_t</code> for this specific file, it&rsquo;s
trivial to use its <code>z_zfsvfs</code> field to access the <code>zfsvfs_t</code>, and then
the <code>z_log</code> field to access the <code>zilog_t</code>. It&rsquo;s worth noting that the
<code>zilog_t</code> is shared across all files in the same dataset (i.e. there&rsquo;s a
single ZIL per ZFS dataset).</p>

<h3 id="zil-transaction-creation-and-assignment">ZIL Transaction Creation and Assignment</h3>

<p>Once the <code>zilog_t</code> structure is obtained, the next line within
<code>zfs_write</code> pertaining to the ZIL is this one:</p>

<pre><code>zfs_log_write(zilog, tx, TX_WRITE, zp, woff, tx_bytes, ioflag);
</code></pre>

<p>The <code>zfs_log_write</code> function is used to create new <code>itx</code>s, as well as
insert them into one of the ZIL&rsquo;s list of transactions.</p>

<h4 id="zil-itx-create"><code>zil_itx_create</code></h4>

<p>Inside of <code>zil_log_write</code>, the function <code>zil_itx_create</code> is used to
allocate one or more <code>itx_t</code> structures to represent the <code>write</code> system
within the in-memory portion of the ZIL. That can be seen here:</p>

<pre><code>while (resid) {
	itx_t *itx;
	lr_write_t *lr;
	ssize_t len;

	/*
	 * If the write would overflow the largest block then split it.
	 */
	if (write_state != WR_INDIRECT &amp;&amp; resid &gt; ZIL_MAX_LOG_DATA)
		len = SPA_OLD_MAXBLOCKSIZE &gt;&gt; 1;
	else
		len = resid;

	// ... &lt;snip&gt; ...

	itx = zil_itx_create(txtype, sizeof (*lr) +
	    (write_state == WR_COPIED ? len : 0));

	// ... &lt;snip&gt; ...

	resid -= len;
}
</code></pre>

<p>Where <code>zil_itx_create</code> simply allocates and initializes the in-memory
<code>itx_t</code> structure:</p>

<pre><code>itx_t *
zil_itx_create(uint64_t txtype, size_t lrsize)
{
	itx_t *itx;

	lrsize = P2ROUNDUP_TYPED(lrsize, sizeof (uint64_t), size_t);

	itx = kmem_alloc(offsetof(itx_t, itx_lr) + lrsize, KM_SLEEP);
	itx-&gt;itx_lr.lrc_txtype = txtype;
	itx-&gt;itx_lr.lrc_reclen = lrsize;
	itx-&gt;itx_sod = lrsize; /* if write &amp; WR_NEED_COPY will be increased */
	itx-&gt;itx_lr.lrc_seq = 0;	/* defensive */
	itx-&gt;itx_sync = B_TRUE;		/* default is synchronous */

	return (itx);
}
</code></pre>

<p>Thus, for a single <code>write</code> (and single call to <code>zfs_log_write</code>), 1 or
more <code>itx</code>s will be created to represent the system call.</p>

<h4 id="zil-itx-assign"><code>zil_itx_assign</code></h4>

<p>At this point, the <code>itx</code>s representing the <code>write</code> will have been
allocated and initialized, but they&rsquo;re not yet part of the ZIL. In order
to add the <code>itx</code>s to the ZIL, the <code>zil_itx_assign</code> function is used.
Expanding the previous code snippet from <code>zfs_write</code>, we can see that
<code>zil_itx_assign</code> is called immediately after the individual <code>itx</code>s are
created and initialized:</p>

<pre><code>while (resid) {
	itx_t *itx;
	lr_write_t *lr;
	ssize_t len;

	/*
	 * If the write would overflow the largest block then split it.
	 */
	if (write_state != WR_INDIRECT &amp;&amp; resid &gt; ZIL_MAX_LOG_DATA)
		len = SPA_OLD_MAXBLOCKSIZE &gt;&gt; 1;
	else
		len = resid;

	itx = zil_itx_create(txtype, sizeof (*lr) +
	    (write_state == WR_COPIED ? len : 0));
	lr = (lr_write_t *)&amp;itx-&gt;itx_lr;
	if (write_state == WR_COPIED &amp;&amp; dmu_read(zp-&gt;z_zfsvfs-&gt;z_os,
	    zp-&gt;z_id, off, len, lr + 1, DMU_READ_NO_PREFETCH) != 0) {
		zil_itx_destroy(itx);
		itx = zil_itx_create(txtype, sizeof (*lr));
		lr = (lr_write_t *)&amp;itx-&gt;itx_lr;
		write_state = WR_NEED_COPY;
	}

	itx-&gt;itx_wr_state = write_state;
	if (write_state == WR_NEED_COPY)
		itx-&gt;itx_sod += len;
	lr-&gt;lr_foid = zp-&gt;z_id;
	lr-&gt;lr_offset = off;
	lr-&gt;lr_length = len;
	lr-&gt;lr_blkoff = 0;
	BP_ZERO(&amp;lr-&gt;lr_blkptr);

	itx-&gt;itx_private = zp-&gt;z_zfsvfs;

	if (!(ioflag &amp; (FSYNC | FDSYNC)) &amp;&amp; (zp-&gt;z_sync_cnt == 0) &amp;&amp;
	    (fsync_cnt == 0))
		itx-&gt;itx_sync = B_FALSE;

	zil_itx_assign(zilog, itx, tx);

	off += len;
	resid -= len;
}
</code></pre>

<p>The purpose of <code>zil_itx_assign</code> is to insert the new <code>itx</code> into one of
the ZIL&rsquo;s list of transactions; the details of that process is covered
next (it&rsquo;s complicated enough to warrant a new section).</p>

<h3 id="zl-itxg-4-i-sync-list-i-async-tree-and-ia-list"><code>zl_itxg[4]</code>, <code>i_sync_list</code>, <code>i_async_tree</code>, and <code>ia_list</code></h3>

<p>In order to fully understand how a given <code>itx</code> gets inserted into the
in memory representation of the ZIL (via <code>zil_itx_assign</code>), one has to
understand a few things about the <code>zilog_t</code>:</p>

<ol>
<li><p>The <code>zl_itxg</code> field of the <code>zilog_t</code> contains 4 unique <code>itxg_t</code>s,
 and each <code>itxg_t</code> maps to a particular DMU transaction group. Each
 <code>itx</code> created is applicable to a specific DMU transaction (<code>tx</code>),
 which is then applicable to a specific DMU transaction group
 (<code>txg</code>). Thus, the <code>tx</code> is used to determine the <code>txg</code> for this
 specific <code>itx</code>, and the <code>txg</code> is used to determine which of the 4
 different <code>itxg_t</code>s (from the <code>zl_itxg</code> array) will be used when
 inserting the <code>itx</code>.</p></li>

<li><p>Each of the 4 <code>itxg_t</code>&rsquo;s maintain a:</p>

<ul>
<li><code>i_sync_list</code> which is a simple linked list of <code>itx_t</code> structures.</li>
<li><code>i_async_tree</code> which is an AVL tree of <code>itx_async_node_t</code>
structures (indexed by DMU object ID), where each node in the tree
(each <code>itx_async_node_t</code>) maintains its own <code>ia_list</code>, which is a
linked list of <code>itx_t</code> structures.</li>
</ul></li>
</ol>

<p>Below is a diagram that attempts to illustrate this (it&rsquo;s not as
complicated as the above explanation might sound):</p>

<p><img src="zil-itx-lists.png" alt="ZIL Transaction Lists" /></p>

<h3 id="insertion-of-a-zil-transaction">Insertion of a ZIL Transaction</h3>

<p>So, when <code>zil_itx_assign</code> is called in the context of <code>zfs_log_write</code>,
the <code>itx</code> will be inserted into one of <code>itxg_t</code>&rsquo;s lists described in the
previous section. The following logic/criteria is used to decide which
list to use, when inserting the new <code>itx</code>:</p>

<ol>
<li>First, which of the 4 <code>itxg_t</code>s needs to be chosen. The <code>txg</code> that
 the given <code>itx</code> is associated with is used to make this decision.
 <code>dmu_tx_get_txg</code> is used to obtain the <code>txg</code> from the <code>itx</code>&rsquo;s <code>tx</code>,
 and then the <code>txg</code> is bit-wise AND-ed with <code>TXG_MASK</code> to determine
 which <code>itxg_t</code> to use.</li>
<li>Now that the <code>itxg_t</code> is chosen, the linked list that will be used
 when inserting the <code>itx</code> needs to be decided. This depends on the
 value of the <code>itx</code>&rsquo;s <code>itx_sync</code> field (i.e. based on if the write
 is synchronous or not):

<ul>
<li>If <code>itx_sync</code> is <code>TRUE</code>, the <code>itx</code> is appended to the
<code>i_sync_list</code> of the <code>itxg_t</code> chosen in (1).</li>
<li>If <code>itx_sync</code> is <code>FALSE</code>, <code>avl_find</code> is used to find the
<code>itx_asnyc_node_t</code> for the specific file being written, from
the <code>i_async_tree</code> of the <code>itxg_t</code> chosen in (1). Once the
<code>itx_async_node_t</code> is found, the <code>itx</code> is appended to that
structure&rsquo;s <code>ia_list</code>.</li>
</ul></li>
</ol>

<p>Once the <code>itx</code> has been assigned to either the <code>i_sync_list</code> or one of
the <code>ia_list</code> lists (contained in the <code>itx_async_node_t</code>), the work of
<code>zfs_log_write</code> is finished. This specific <code>write</code> system call has been
recorded and inserted into the in-memory representation of the ZIL, but
this record will still be lost if a power loss were to happen at this
point.</p>

<p>In order for the record of the <code>write</code> to persist in the event of a
power loss (or an equivalent operating system crash), the <code>itx</code>s need
to be written to the on-disk representation of the ZIL. Notes on that
process will be left for another post.</p>

</main>
    <footer>
  <hr />

<div class="footer">
  <div id="footer-left">
    <a href="mailto:me@prakashsurya.com">me@prakashsurya.com</a>
  </div>

  <div id="footer-center">
    Published: 15 Mar 2017
  </div>

  <div id="footer-right">
    Last Modified: 15 Mar 2017
  </div>
</div>

</footer>
  </body>
</html>
